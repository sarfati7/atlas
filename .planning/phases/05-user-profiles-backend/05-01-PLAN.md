---
phase: 05-user-profiles-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/atlas/domain/entities/effective_configuration.py
  - backend/src/atlas/domain/entities/__init__.py
  - backend/src/atlas/application/services/user_profile_service.py
  - backend/src/atlas/application/services/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dashboard aggregation returns user info, teams, available items count, and config status"
    - "Available items computation filters by company-wide + user's teams"
    - "Effective configuration merges org -> team -> user levels with source markers"
  artifacts:
    - path: "backend/src/atlas/domain/entities/effective_configuration.py"
      provides: "EffectiveConfiguration dataclass"
      contains: "class EffectiveConfiguration"
    - path: "backend/src/atlas/application/services/user_profile_service.py"
      provides: "UserProfileService with get_dashboard, get_available_items, get_effective_configuration"
      exports: ["UserProfileService", "UserDashboard", "UserNotFoundError"]
  key_links:
    - from: "user_profile_service.py"
      to: "AbstractUserRepository, AbstractTeamRepository, AbstractCatalogRepository"
      via: "constructor injection"
      pattern: "self\\._.*_repo"
    - from: "user_profile_service.py"
      to: "AbstractContentRepository"
      via: "get_content calls for org/team/user configs"
      pattern: "content_repo\\.get_content"
---

<objective>
Create domain entity and service layer for user profile aggregation and configuration inheritance

Purpose: Provide the business logic layer that aggregates user dashboard data from multiple repositories and computes effective configuration by merging org -> team -> user configuration levels.

Output:
- EffectiveConfiguration dataclass in domain layer
- UserProfileService in application layer with 3 methods
- Response models for dashboard and items
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-user-profiles-backend/05-RESEARCH.md

# Prior art - service layer pattern
@backend/src/atlas/application/services/configuration_service.py

# Existing domain entities
@backend/src/atlas/domain/entities/user.py
@backend/src/atlas/domain/entities/team.py
@backend/src/atlas/domain/entities/catalog_item.py
@backend/src/atlas/domain/entities/user_configuration.py

# Repository interfaces to inject
@backend/src/atlas/domain/interfaces/user_repository.py
@backend/src/atlas/domain/interfaces/team_repository.py
@backend/src/atlas/domain/interfaces/catalog_repository.py
@backend/src/atlas/domain/interfaces/configuration_repository.py
@backend/src/atlas/domain/interfaces/content_repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EffectiveConfiguration domain entity</name>
  <files>
    backend/src/atlas/domain/entities/effective_configuration.py
    backend/src/atlas/domain/entities/__init__.py
  </files>
  <action>
Create EffectiveConfiguration as a dataclass (not Pydantic - simple value object):

```python
from dataclasses import dataclass

@dataclass
class EffectiveConfiguration:
    """Computed effective configuration with source breakdown."""
    content: str              # Final merged configuration
    org_content: str          # Content from org level (empty if none)
    team_content: str         # Combined content from team level(s)
    user_content: str         # Content from user level (empty if none)
```

Update `__init__.py` to export EffectiveConfiguration.

Keep it simple - just data, no methods. The service will handle merging logic.
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend
python -c "from atlas.domain.entities import EffectiveConfiguration; print(EffectiveConfiguration('merged', 'org', 'team', 'user'))"
```
  </verify>
  <done>EffectiveConfiguration dataclass exists and is importable from domain.entities</done>
</task>

<task type="auto">
  <name>Task 2: Create UserProfileService with aggregation and inheritance</name>
  <files>
    backend/src/atlas/application/services/user_profile_service.py
    backend/src/atlas/application/services/__init__.py
  </files>
  <action>
Create UserProfileService following ConfigurationService pattern. Service has 3 main methods:

**Imports and Types:**
```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from uuid import UUID
import asyncio

from pydantic import BaseModel

from atlas.domain.entities import (
    CatalogItem, CatalogItemType, EffectiveConfiguration, Team, User
)
from atlas.domain.interfaces import (
    AbstractCatalogRepository,
    AbstractConfigurationRepository,
    AbstractContentRepository,
    AbstractTeamRepository,
    AbstractUserRepository,
)
```

**Response Models (define in same file):**

```python
class TeamSummary(BaseModel):
    id: UUID
    name: str
    member_count: int

class CatalogItemSummary(BaseModel):
    id: UUID
    type: CatalogItemType
    name: str
    description: str

class UserDashboard(BaseModel):
    user_id: UUID
    username: str
    email: str
    teams: list[TeamSummary]
    available_skills: int
    available_mcps: int
    available_tools: int
    has_configuration: bool
    configuration_updated_at: Optional[datetime]
```

**Error Class:**
```python
class UserNotFoundError(Exception):
    """Raised when user doesn't exist."""
    pass
```

**Service Class:**

Constructor accepts 5 repositories:
- user_repo: AbstractUserRepository
- team_repo: AbstractTeamRepository
- catalog_repo: AbstractCatalogRepository
- config_repo: AbstractConfigurationRepository
- content_repo: AbstractContentRepository

**Method 1: get_dashboard(user_id: UUID) -> UserDashboard**
1. Fetch user (raise UserNotFoundError if None)
2. Use asyncio.gather for parallel fetch: teams, all_items, config
3. Filter available items: team_id is None OR team_id in user.team_ids
4. Count by type (SKILL, MCP, TOOL)
5. Return UserDashboard with all aggregated data

**Method 2: get_available_items(user_id: UUID) -> list[CatalogItemSummary]**
1. Fetch user (return empty list if None - don't fail)
2. Fetch all catalog items
3. Filter: team_id is None OR team_id in user.team_ids
4. Convert to CatalogItemSummary list

**Method 3: get_effective_configuration(user_id: UUID) -> EffectiveConfiguration**
Well-known paths:
- ORG_CONFIG_PATH = "configs/organization/claude.md"
- Team path: f"configs/teams/{team_id}/claude.md"

1. Fetch user's teams
2. Fetch user's config metadata from config_repo
3. Use asyncio.gather for parallel content fetches:
   - org config from content_repo
   - each team's config from content_repo
   - user config from content_repo (if user has config)
4. Build merged content with section markers:
   - "# Organization Configuration\n\n{org_content}"
   - "# Team: {team_name}\n\n{team_content}" for each team
   - "# Personal Configuration\n\n{user_content}"
   - Join with "\n\n---\n\n"
5. Return EffectiveConfiguration with merged content and individual parts

Handle missing configs gracefully - treat as empty string.

Update `__init__.py` to export UserProfileService, UserDashboard, UserNotFoundError.
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend
python -c "
from atlas.application.services import UserProfileService, UserDashboard, UserNotFoundError
print('UserProfileService:', UserProfileService)
print('UserDashboard:', UserDashboard)
print('UserNotFoundError:', UserNotFoundError)
"
```
  </verify>
  <done>
UserProfileService exists with get_dashboard, get_available_items, get_effective_configuration methods.
Response models UserDashboard, TeamSummary, CatalogItemSummary defined.
UserNotFoundError exception defined.
All exported from application.services.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend

# Run existing tests to ensure no regressions
python -m pytest tests/ -v --tb=short 2>/dev/null || echo "Tests not set up yet - skipping"

# Type check new files
python -c "
from atlas.domain.entities import EffectiveConfiguration
from atlas.application.services import UserProfileService, UserDashboard, UserNotFoundError

# Verify EffectiveConfiguration is a dataclass
from dataclasses import is_dataclass
assert is_dataclass(EffectiveConfiguration), 'EffectiveConfiguration must be a dataclass'

# Verify UserDashboard is Pydantic
from pydantic import BaseModel
assert issubclass(UserDashboard, BaseModel), 'UserDashboard must be Pydantic'

print('All verifications passed')
"
```
</verification>

<success_criteria>
- EffectiveConfiguration dataclass in domain layer with 4 string fields
- UserProfileService in application layer with 3 async methods
- UserDashboard Pydantic model with user info, teams, counts, config status
- CatalogItemSummary and TeamSummary models for response composition
- UserNotFoundError exception for user lookup failures
- All imports work from package __init__.py files
</success_criteria>

<output>
After completion, create `.planning/phases/05-user-profiles-backend/05-01-SUMMARY.md`
</output>
