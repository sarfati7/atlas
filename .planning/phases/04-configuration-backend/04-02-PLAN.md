---
phase: 04-configuration-backend
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/atlas/adapters/postgresql/repositories/configuration_repository.py
  - backend/src/atlas/adapters/postgresql/repositories/__init__.py
  - backend/src/atlas/adapters/in_memory/repositories/configuration_repository.py
  - backend/src/atlas/adapters/in_memory/repositories/__init__.py
  - backend/src/atlas/adapters/github/content_repository.py
  - backend/src/atlas/adapters/in_memory/content_repository.py
autonomous: true

must_haves:
  truths:
    - "PostgresConfigurationRepository implements all AbstractConfigurationRepository methods"
    - "InMemoryConfigurationRepository implements all AbstractConfigurationRepository methods"
    - "GitHubContentRepository implements get_version_history and get_content_at_version"
    - "InMemoryContentRepository implements get_version_history and get_content_at_version"
    - "All repository implementations are importable from their packages"
  artifacts:
    - path: "backend/src/atlas/adapters/postgresql/repositories/configuration_repository.py"
      provides: "PostgreSQL implementation of configuration repository"
      exports: ["PostgresConfigurationRepository"]
    - path: "backend/src/atlas/adapters/in_memory/repositories/configuration_repository.py"
      provides: "In-memory implementation for testing"
      exports: ["InMemoryConfigurationRepository"]
    - path: "backend/src/atlas/adapters/github/content_repository.py"
      provides: "Version history methods via PyGithub"
      contains: "get_version_history"
    - path: "backend/src/atlas/adapters/in_memory/content_repository.py"
      provides: "Version history methods for testing"
      contains: "get_version_history"
  key_links:
    - from: "PostgresConfigurationRepository"
      to: "UserConfigurationModel"
      via: "SQLModel queries"
      pattern: "UserConfigurationModel"
    - from: "GitHubContentRepository.get_version_history"
      to: "PyGithub get_commits"
      via: "asyncio.to_thread wrapper"
      pattern: "get_commits.*path="
---

<objective>
Implement all repository adapters for configuration management.

Purpose: Provides concrete implementations of the configuration repository interfaces defined in 04-01. These adapters handle the actual database and git operations for configuration CRUD and version history.

Output:
- PostgresConfigurationRepository (production database)
- InMemoryConfigurationRepository (testing)
- Extended GitHubContentRepository with version history methods
- Extended InMemoryContentRepository with version history methods
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-configuration-backend/04-RESEARCH.md

# Prior plan creates these
@backend/src/atlas/domain/entities/user_configuration.py
@backend/src/atlas/domain/interfaces/configuration_repository.py
@backend/src/atlas/domain/interfaces/content_repository.py

# Existing patterns to follow
@backend/src/atlas/adapters/postgresql/repositories/user_repository.py
@backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py
@backend/src/atlas/adapters/in_memory/repositories/user_repository.py
@backend/src/atlas/adapters/github/content_repository.py
@backend/src/atlas/adapters/in_memory/content_repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PostgresConfigurationRepository</name>
  <files>
    backend/src/atlas/adapters/postgresql/repositories/configuration_repository.py
    backend/src/atlas/adapters/postgresql/repositories/__init__.py
  </files>
  <action>
Create PostgresConfigurationRepository following existing user_repository.py patterns:

```python
# configuration_repository.py
from datetime import datetime
from typing import Optional
from uuid import UUID

from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession

from atlas.adapters.postgresql.models import UserConfigurationModel
from atlas.domain.entities import UserConfiguration
from atlas.domain.interfaces import AbstractConfigurationRepository


class PostgresConfigurationRepository(AbstractConfigurationRepository):
    """PostgreSQL implementation of configuration repository."""

    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def get_by_user_id(self, user_id: UUID) -> Optional[UserConfiguration]:
        """Get configuration for a user."""
        stmt = select(UserConfigurationModel).where(
            UserConfigurationModel.user_id == user_id
        )
        result = await self._session.exec(stmt)
        model = result.first()
        if model is None:
            return None
        return self._to_entity(model)

    async def get_by_id(self, config_id: UUID) -> Optional[UserConfiguration]:
        """Get configuration by ID."""
        stmt = select(UserConfigurationModel).where(
            UserConfigurationModel.id == config_id
        )
        result = await self._session.exec(stmt)
        model = result.first()
        if model is None:
            return None
        return self._to_entity(model)

    async def save(self, config: UserConfiguration) -> UserConfiguration:
        """Save or update configuration (upsert by user_id)."""
        # Check if exists
        existing = await self.get_by_user_id(config.user_id)

        if existing:
            # Update existing
            stmt = select(UserConfigurationModel).where(
                UserConfigurationModel.user_id == config.user_id
            )
            result = await self._session.exec(stmt)
            model = result.first()
            model.git_path = config.git_path
            model.current_commit_sha = config.current_commit_sha
            model.updated_at = datetime.utcnow()
            self._session.add(model)
            await self._session.commit()
            await self._session.refresh(model)
            return self._to_entity(model)
        else:
            # Create new
            model = UserConfigurationModel(
                id=config.id,
                user_id=config.user_id,
                git_path=config.git_path,
                current_commit_sha=config.current_commit_sha,
                created_at=config.created_at,
                updated_at=config.updated_at,
            )
            self._session.add(model)
            await self._session.commit()
            await self._session.refresh(model)
            return self._to_entity(model)

    async def delete(self, config_id: UUID) -> bool:
        """Delete configuration by ID."""
        stmt = select(UserConfigurationModel).where(
            UserConfigurationModel.id == config_id
        )
        result = await self._session.exec(stmt)
        model = result.first()
        if model is None:
            return False
        await self._session.delete(model)
        await self._session.commit()
        return True

    def _to_entity(self, model: UserConfigurationModel) -> UserConfiguration:
        """Convert SQLModel to domain entity."""
        return UserConfiguration(
            id=model.id,
            user_id=model.user_id,
            git_path=model.git_path,
            current_commit_sha=model.current_commit_sha,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )
```

Update repositories/__init__.py to export PostgresConfigurationRepository.
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "from atlas.adapters.postgresql.repositories import PostgresConfigurationRepository; print('OK')"
```
  </verify>
  <done>PostgresConfigurationRepository is importable and implements all AbstractConfigurationRepository methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement InMemoryConfigurationRepository</name>
  <files>
    backend/src/atlas/adapters/in_memory/repositories/configuration_repository.py
    backend/src/atlas/adapters/in_memory/repositories/__init__.py
  </files>
  <action>
Create InMemoryConfigurationRepository following existing in_memory patterns:

```python
# configuration_repository.py
from datetime import datetime
from typing import Optional
from uuid import UUID

from atlas.domain.entities import UserConfiguration
from atlas.domain.interfaces import AbstractConfigurationRepository


class InMemoryConfigurationRepository(AbstractConfigurationRepository):
    """In-memory implementation of configuration repository for testing."""

    def __init__(self) -> None:
        self._configs: dict[UUID, UserConfiguration] = {}
        self._by_user: dict[UUID, UUID] = {}  # user_id -> config_id mapping

    async def get_by_user_id(self, user_id: UUID) -> Optional[UserConfiguration]:
        """Get configuration for a user."""
        config_id = self._by_user.get(user_id)
        if config_id is None:
            return None
        return self._configs.get(config_id)

    async def get_by_id(self, config_id: UUID) -> Optional[UserConfiguration]:
        """Get configuration by ID."""
        return self._configs.get(config_id)

    async def save(self, config: UserConfiguration) -> UserConfiguration:
        """Save or update configuration (upsert by user_id)."""
        existing_id = self._by_user.get(config.user_id)

        if existing_id:
            # Update existing - use same ID
            updated = UserConfiguration(
                id=existing_id,
                user_id=config.user_id,
                git_path=config.git_path,
                current_commit_sha=config.current_commit_sha,
                created_at=self._configs[existing_id].created_at,
                updated_at=datetime.utcnow(),
            )
            self._configs[existing_id] = updated
            return updated
        else:
            # Create new
            self._configs[config.id] = config
            self._by_user[config.user_id] = config.id
            return config

    async def delete(self, config_id: UUID) -> bool:
        """Delete configuration by ID."""
        config = self._configs.get(config_id)
        if config is None:
            return False
        del self._configs[config_id]
        del self._by_user[config.user_id]
        return True
```

Update in_memory/repositories/__init__.py to export InMemoryConfigurationRepository.
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "from atlas.adapters.in_memory.repositories import InMemoryConfigurationRepository; print('OK')"
```
  </verify>
  <done>InMemoryConfigurationRepository is importable and implements all AbstractConfigurationRepository methods</done>
</task>

<task type="auto">
  <name>Task 3: Extend content repositories with version history methods</name>
  <files>
    backend/src/atlas/adapters/github/content_repository.py
    backend/src/atlas/adapters/in_memory/content_repository.py
  </files>
  <action>
1. Add version history methods to GitHubContentRepository:

```python
# Add to github/content_repository.py

# Add import at top:
from atlas.domain.entities import ConfigurationVersion

# Add these methods to GitHubContentRepository class:

async def get_version_history(
    self,
    path: str,
    limit: int = 50
) -> list[ConfigurationVersion]:
    """Get commit history for a file."""
    try:
        commits = await asyncio.to_thread(
            self._repo.get_commits,
            path=path
        )
        versions = []
        for i, commit in enumerate(commits):
            if i >= limit:
                break
            versions.append(ConfigurationVersion(
                commit_sha=commit.sha,
                message=commit.commit.message,
                author=commit.commit.author.name if commit.commit.author else "Unknown",
                timestamp=commit.commit.author.date if commit.commit.author else datetime.utcnow(),
            ))
        return versions
    except GithubException:
        return []

async def get_content_at_version(
    self,
    path: str,
    commit_sha: str
) -> Optional[str]:
    """Get file content at specific commit SHA."""
    try:
        content = await asyncio.to_thread(
            self._repo.get_contents,
            path,
            ref=commit_sha
        )
        return content.decoded_content.decode("utf-8")
    except GithubException:
        return None
```

Add `from datetime import datetime` import if not present.

2. Add version history methods to InMemoryContentRepository:

```python
# Add to in_memory/content_repository.py

# Add import at top:
from datetime import datetime
from atlas.domain.entities import ConfigurationVersion

# Add these methods to InMemoryContentRepository class:

async def get_version_history(
    self,
    path: str,
    limit: int = 50
) -> list[ConfigurationVersion]:
    """Get version history (in-memory returns single version if file exists)."""
    if path not in self._storage:
        return []
    # In-memory doesn't track history, return current "version"
    return [
        ConfigurationVersion(
            commit_sha=self._commits.get(path, "in-memory-sha"),
            message="In-memory content",
            author="test",
            timestamp=datetime.utcnow(),
        )
    ]

async def get_content_at_version(
    self,
    path: str,
    commit_sha: str
) -> Optional[str]:
    """Get content at version (in-memory returns current content if SHA matches)."""
    # In-memory doesn't track versions, just return current content
    return self._storage.get(path)
```

Note: In-memory implementation is simplified since it doesn't maintain real version history. This is acceptable for testing as long as the interface is satisfied.
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.adapters.github.content_repository import GitHubContentRepository
from atlas.adapters.in_memory.content_repository import InMemoryContentRepository
import inspect
# Check methods exist
github_methods = [m for m in dir(GitHubContentRepository) if 'version' in m.lower()]
inmem_methods = [m for m in dir(InMemoryContentRepository) if 'version' in m.lower()]
print('GitHub methods:', github_methods)
print('InMemory methods:', inmem_methods)
"
```
  </verify>
  <done>Both GitHubContentRepository and InMemoryContentRepository have get_version_history and get_content_at_version methods</done>
</task>

</tasks>

<verification>
All repository implementations complete and importable:

```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.adapters.postgresql.repositories import PostgresConfigurationRepository
from atlas.adapters.in_memory.repositories import InMemoryConfigurationRepository
from atlas.adapters.github.content_repository import GitHubContentRepository
from atlas.adapters.in_memory.content_repository import InMemoryContentRepository
from atlas.domain.interfaces import AbstractConfigurationRepository, AbstractContentRepository

# Verify PostgresConfigurationRepository implements interface
assert issubclass(PostgresConfigurationRepository, AbstractConfigurationRepository)

# Verify InMemoryConfigurationRepository implements interface
assert issubclass(InMemoryConfigurationRepository, AbstractConfigurationRepository)

# Verify content repos have version methods
assert hasattr(GitHubContentRepository, 'get_version_history')
assert hasattr(GitHubContentRepository, 'get_content_at_version')
assert hasattr(InMemoryContentRepository, 'get_version_history')
assert hasattr(InMemoryContentRepository, 'get_content_at_version')

print('All repository implementations verified')
"
```
</verification>

<success_criteria>
- PostgresConfigurationRepository implements get_by_user_id, get_by_id, save, delete
- InMemoryConfigurationRepository implements same methods for testing
- GitHubContentRepository has get_version_history using PyGithub get_commits(path=...)
- GitHubContentRepository has get_content_at_version using get_contents(path, ref=sha)
- InMemoryContentRepository has both version methods (simplified for testing)
- All implementations use asyncio.to_thread for PyGithub calls
</success_criteria>

<output>
After completion, create `.planning/phases/04-configuration-backend/04-02-SUMMARY.md`
</output>
