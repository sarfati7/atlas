---
phase: 04-configuration-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/atlas/domain/entities/user_configuration.py
  - backend/src/atlas/domain/interfaces/configuration_repository.py
  - backend/src/atlas/domain/interfaces/content_repository.py
  - backend/src/atlas/domain/interfaces/__init__.py
  - backend/src/atlas/adapters/postgresql/models.py
  - backend/migrations/versions/add_user_configurations.py
autonomous: true

must_haves:
  truths:
    - "UserConfiguration entity exists with user_id, git_path, current_commit_sha"
    - "ConfigurationVersion dataclass exists for version history"
    - "AbstractConfigurationRepository interface defines CRUD operations"
    - "AbstractContentRepository interface includes version history methods"
    - "UserConfigurationModel SQLModel table exists with correct fields"
    - "Alembic migration creates user_configurations table"
  artifacts:
    - path: "backend/src/atlas/domain/entities/user_configuration.py"
      provides: "UserConfiguration entity"
      min_lines: 20
    - path: "backend/src/atlas/domain/interfaces/configuration_repository.py"
      provides: "Repository interface for configuration metadata"
      exports: ["AbstractConfigurationRepository"]
    - path: "backend/src/atlas/domain/interfaces/content_repository.py"
      provides: "Extended interface with version methods"
      contains: "get_version_history"
    - path: "backend/src/atlas/adapters/postgresql/models.py"
      provides: "UserConfigurationModel table"
      contains: "class UserConfigurationModel"
    - path: "backend/migrations/versions/"
      provides: "Migration file for user_configurations table"
  key_links:
    - from: "UserConfigurationModel"
      to: "UserModel"
      via: "foreign key user_id"
      pattern: 'foreign_key="users.id"'
    - from: "UserConfiguration entity"
      to: "AbstractConfigurationRepository"
      via: "repository methods accept/return entity"
---

<objective>
Define domain layer and database foundation for user configuration management.

Purpose: Establishes the data model for tracking user configurations (claude.md files) with git-backed versioning. This is the foundation that all other configuration plans build upon.

Output:
- UserConfiguration domain entity with version tracking fields
- ConfigurationVersion dataclass for history entries
- AbstractConfigurationRepository interface for metadata storage
- Extended AbstractContentRepository with version history methods
- UserConfigurationModel SQLModel table
- Alembic migration for user_configurations table
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-configuration-backend/04-RESEARCH.md

# Existing patterns to follow
@backend/src/atlas/domain/entities/catalog_item.py
@backend/src/atlas/domain/entities/user.py
@backend/src/atlas/domain/interfaces/content_repository.py
@backend/src/atlas/domain/interfaces/catalog_repository.py
@backend/src/atlas/adapters/postgresql/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserConfiguration entity and ConfigurationVersion dataclass</name>
  <files>
    backend/src/atlas/domain/entities/user_configuration.py
    backend/src/atlas/domain/entities/__init__.py
  </files>
  <action>
Create UserConfiguration entity using Pydantic BaseModel (following existing User/CatalogItem patterns):

```python
# user_configuration.py
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4

from pydantic import BaseModel


@dataclass
class ConfigurationVersion:
    """Represents a version (commit) of a configuration file."""
    commit_sha: str
    message: str
    author: str
    timestamp: datetime


class UserConfiguration(BaseModel):
    """
    Domain entity for user configuration.

    Tracks metadata about a user's claude.md configuration file.
    Actual content is stored in git; this tracks the git path and current version.
    """
    id: UUID = uuid4()
    user_id: UUID
    git_path: str  # e.g., "configs/users/{user_id}/claude.md"
    current_commit_sha: str = ""  # Empty until first save
    created_at: datetime = datetime.utcnow()
    updated_at: datetime = datetime.utcnow()
```

Update entities/__init__.py to export:
- UserConfiguration
- ConfigurationVersion
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "from atlas.domain.entities import UserConfiguration, ConfigurationVersion; print('OK')"
```
  </verify>
  <done>UserConfiguration entity and ConfigurationVersion dataclass exist and are importable from domain.entities</done>
</task>

<task type="auto">
  <name>Task 2: Create AbstractConfigurationRepository interface and extend AbstractContentRepository</name>
  <files>
    backend/src/atlas/domain/interfaces/configuration_repository.py
    backend/src/atlas/domain/interfaces/content_repository.py
    backend/src/atlas/domain/interfaces/__init__.py
  </files>
  <action>
1. Create configuration_repository.py with AbstractConfigurationRepository:

```python
from abc import ABC, abstractmethod
from typing import Optional
from uuid import UUID

from atlas.domain.entities import UserConfiguration


class AbstractConfigurationRepository(ABC):
    """Abstract repository interface for user configuration metadata."""

    @abstractmethod
    async def get_by_user_id(self, user_id: UUID) -> Optional[UserConfiguration]:
        """Get configuration metadata for a user. Returns None if not exists."""
        raise NotImplementedError

    @abstractmethod
    async def get_by_id(self, config_id: UUID) -> Optional[UserConfiguration]:
        """Get configuration by its ID."""
        raise NotImplementedError

    @abstractmethod
    async def save(self, config: UserConfiguration) -> UserConfiguration:
        """Save or update configuration metadata (upsert by user_id)."""
        raise NotImplementedError

    @abstractmethod
    async def delete(self, config_id: UUID) -> bool:
        """Delete configuration metadata. Returns True if deleted."""
        raise NotImplementedError
```

2. Extend AbstractContentRepository in content_repository.py by adding two new abstract methods:

```python
from atlas.domain.entities import ConfigurationVersion

# Add to existing class (after get_commit_sha method):

@abstractmethod
async def get_version_history(
    self,
    path: str,
    limit: int = 50
) -> list[ConfigurationVersion]:
    """
    Get commit history for a file.

    Returns list of versions ordered by timestamp (newest first).
    Limited to prevent unbounded queries.
    """
    raise NotImplementedError

@abstractmethod
async def get_content_at_version(
    self,
    path: str,
    commit_sha: str
) -> Optional[str]:
    """
    Get file content at a specific commit SHA.

    Returns None if file or commit doesn't exist.
    """
    raise NotImplementedError
```

3. Update interfaces/__init__.py to export AbstractConfigurationRepository
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "from atlas.domain.interfaces import AbstractConfigurationRepository, AbstractContentRepository; print('Methods:', [m for m in dir(AbstractContentRepository) if 'version' in m.lower()])"
```
  </verify>
  <done>AbstractConfigurationRepository exists with CRUD methods; AbstractContentRepository has get_version_history and get_content_at_version abstract methods</done>
</task>

<task type="auto">
  <name>Task 3: Add UserConfigurationModel and create Alembic migration</name>
  <files>
    backend/src/atlas/adapters/postgresql/models.py
    backend/migrations/versions/[timestamp]_add_user_configurations.py
  </files>
  <action>
1. Add UserConfigurationModel to models.py (after CatalogItemModel):

```python
class UserConfigurationModel(SQLModel, table=True):
    """SQLModel table for user configuration metadata."""

    __tablename__ = "user_configurations"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", unique=True, index=True)
    git_path: str = Field(unique=True)  # e.g., "configs/users/{uuid}/claude.md"
    current_commit_sha: str = Field(default="")  # Empty until first save
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

Note: user_id has unique=True because each user has exactly one configuration.

2. Create manual Alembic migration (following existing pattern from 71bef503e77c):

```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend
# Get timestamp for migration filename
TIMESTAMP=$(date +%Y%m%d%H%M%S)
```

Create migration file manually with:
- revision ID: generate a random 12-char hex string
- down_revision: 71bef503e77c (the initial schema)
- Creates user_configurations table with:
  - id (UUID, primary key)
  - user_id (UUID, foreign key to users.id, unique, indexed)
  - git_path (VARCHAR, unique)
  - current_commit_sha (VARCHAR)
  - created_at (TIMESTAMP)
  - updated_at (TIMESTAMP)
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "from atlas.adapters.postgresql.models import UserConfigurationModel; print('Table:', UserConfigurationModel.__tablename__)"
```

Verify migration syntax:
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && uv run alembic check 2>&1 | head -5
```
  </verify>
  <done>UserConfigurationModel exists in models.py; Alembic migration file exists and passes syntax check</done>
</task>

</tasks>

<verification>
All domain layer components ready for repository implementation:

```bash
# Verify all imports work
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.domain.entities import UserConfiguration, ConfigurationVersion
from atlas.domain.interfaces import AbstractConfigurationRepository, AbstractContentRepository
from atlas.adapters.postgresql.models import UserConfigurationModel
print('All imports successful')
print('Entity fields:', UserConfiguration.model_fields.keys())
print('Table name:', UserConfigurationModel.__tablename__)
"
```
</verification>

<success_criteria>
- UserConfiguration entity exists with id, user_id, git_path, current_commit_sha, timestamps
- ConfigurationVersion dataclass exists with commit_sha, message, author, timestamp
- AbstractConfigurationRepository interface defines get_by_user_id, get_by_id, save, delete
- AbstractContentRepository has get_version_history and get_content_at_version abstract methods
- UserConfigurationModel SQLModel table exists with correct fields and constraints
- Alembic migration exists for user_configurations table
</success_criteria>

<output>
After completion, create `.planning/phases/04-configuration-backend/04-01-SUMMARY.md`
</output>
