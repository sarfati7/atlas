---
phase: 04-configuration-backend
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - backend/src/atlas/application/services/__init__.py
  - backend/src/atlas/application/services/configuration_service.py
  - backend/src/atlas/entrypoints/dependencies.py
  - backend/src/atlas/entrypoints/api/routes/configuration.py
  - backend/src/atlas/entrypoints/api/routes/__init__.py
  - backend/src/atlas/entrypoints/app.py
autonomous: true

must_haves:
  truths:
    - "ConfigurationService orchestrates git content and database metadata operations"
    - "GET /api/v1/configuration/me returns user's current configuration content"
    - "PUT /api/v1/configuration/me saves content to git and updates database metadata"
    - "GET /api/v1/configuration/me/history returns version history from git"
    - "POST /api/v1/configuration/me/rollback/{sha} restores previous version"
    - "POST /api/v1/configuration/me/import accepts file upload and saves content"
    - "All endpoints require authentication (CurrentUser dependency)"
  artifacts:
    - path: "backend/src/atlas/application/services/configuration_service.py"
      provides: "Service layer for configuration operations"
      exports: ["ConfigurationService"]
      min_lines: 80
    - path: "backend/src/atlas/entrypoints/api/routes/configuration.py"
      provides: "REST endpoints for configuration management"
      min_lines: 100
    - path: "backend/src/atlas/entrypoints/dependencies.py"
      provides: "Dependency injection for ConfigurationService"
      contains: "get_configuration_service"
  key_links:
    - from: "configuration routes"
      to: "ConfigurationService"
      via: "ConfigService dependency"
      pattern: "ConfigService"
    - from: "ConfigurationService.save_configuration"
      to: "content_repo.save_content"
      via: "git commit"
      pattern: "save_content"
    - from: "ConfigurationService.save_configuration"
      to: "config_repo.save"
      via: "database update"
      pattern: "_config_repo.save"
---

<objective>
Implement ConfigurationService and all REST API endpoints for configuration management.

Purpose: Delivers the complete API layer for configuration CRUD, version history, rollback, and file import. The service layer orchestrates git content storage with database metadata tracking.

Output:
- ConfigurationService with save, get, history, rollback, import operations
- Dependency injection setup for service and repositories
- REST endpoints: GET/PUT /me, GET /me/history, POST /me/rollback/{sha}, POST /me/import
- Router registration in app.py
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-configuration-backend/04-RESEARCH.md

# Prior plans create these
@backend/src/atlas/domain/entities/user_configuration.py
@backend/src/atlas/domain/interfaces/configuration_repository.py
@backend/src/atlas/adapters/postgresql/repositories/configuration_repository.py
@backend/src/atlas/adapters/github/content_repository.py

# Existing patterns to follow
@backend/src/atlas/entrypoints/api/routes/catalog.py
@backend/src/atlas/entrypoints/api/routes/auth.py
@backend/src/atlas/entrypoints/dependencies.py
@backend/src/atlas/entrypoints/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConfigurationService</name>
  <files>
    backend/src/atlas/application/__init__.py
    backend/src/atlas/application/services/__init__.py
    backend/src/atlas/application/services/configuration_service.py
  </files>
  <action>
Create the application service layer structure and ConfigurationService:

1. Create backend/src/atlas/application/services/__init__.py with exports
2. Update backend/src/atlas/application/__init__.py if needed

3. Create configuration_service.py:

```python
"""Configuration service - Orchestrates git content + database metadata."""

from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4

from atlas.domain.entities import ConfigurationVersion, UserConfiguration
from atlas.domain.interfaces import (
    AbstractConfigurationRepository,
    AbstractContentRepository,
)


class ConfigurationNotFoundError(Exception):
    """Raised when configuration doesn't exist for user."""
    pass


class VersionNotFoundError(Exception):
    """Raised when requested version (commit SHA) doesn't exist."""
    pass


class ConfigurationService:
    """
    Service layer for configuration operations.

    Orchestrates git content storage with database metadata tracking.
    Git stores actual claude.md content; database stores user-to-path mapping.
    """

    def __init__(
        self,
        config_repo: AbstractConfigurationRepository,
        content_repo: AbstractContentRepository,
    ) -> None:
        self._config_repo = config_repo
        self._content_repo = content_repo

    def _get_user_config_path(self, user_id: UUID) -> str:
        """Generate git path for user's configuration."""
        return f"configs/users/{user_id}/claude.md"

    async def get_configuration(self, user_id: UUID) -> tuple[str, UserConfiguration]:
        """
        Get user's current configuration content and metadata.

        Returns tuple of (content, metadata).
        Returns empty content if user has no configuration yet.
        """
        config = await self._config_repo.get_by_user_id(user_id)

        if config is None:
            # No config exists yet - return empty content with placeholder metadata
            path = self._get_user_config_path(user_id)
            return "", UserConfiguration(
                id=uuid4(),
                user_id=user_id,
                git_path=path,
                current_commit_sha="",
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow(),
            )

        # Fetch content from git
        content = await self._content_repo.get_content(config.git_path)
        return content or "", config

    async def save_configuration(
        self,
        user_id: UUID,
        content: str,
        message: Optional[str] = None,
    ) -> UserConfiguration:
        """
        Save configuration content with git versioning.

        Creates or updates the configuration, committing to git and
        updating database metadata.
        """
        path = self._get_user_config_path(user_id)
        commit_message = message or f"Update configuration for user {user_id}"

        # Save to git (creates new commit)
        commit_sha = await self._content_repo.save_content(
            path=path,
            content=content,
            message=commit_message,
        )

        # Get or create database record
        config = await self._config_repo.get_by_user_id(user_id)
        if config is None:
            config = UserConfiguration(
                id=uuid4(),
                user_id=user_id,
                git_path=path,
                current_commit_sha=commit_sha,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow(),
            )
        else:
            config = UserConfiguration(
                id=config.id,
                user_id=config.user_id,
                git_path=config.git_path,
                current_commit_sha=commit_sha,
                created_at=config.created_at,
                updated_at=datetime.utcnow(),
            )

        # Save metadata to database
        return await self._config_repo.save(config)

    async def get_version_history(
        self,
        user_id: UUID,
        limit: int = 50,
    ) -> list[ConfigurationVersion]:
        """
        Get version history for user's configuration.

        Returns empty list if no configuration exists yet.
        """
        config = await self._config_repo.get_by_user_id(user_id)
        if config is None:
            return []

        return await self._content_repo.get_version_history(
            path=config.git_path,
            limit=limit,
        )

    async def rollback_to_version(
        self,
        user_id: UUID,
        commit_sha: str,
    ) -> UserConfiguration:
        """
        Rollback configuration to a previous version.

        Gets content from historical commit and saves as new commit.
        """
        config = await self._config_repo.get_by_user_id(user_id)
        if config is None:
            raise ConfigurationNotFoundError(f"No configuration for user {user_id}")

        # Get content from historical commit
        old_content = await self._content_repo.get_content_at_version(
            path=config.git_path,
            commit_sha=commit_sha,
        )
        if old_content is None:
            raise VersionNotFoundError(f"Version {commit_sha} not found")

        # Save as new commit (creates new version pointing to old content)
        return await self.save_configuration(
            user_id=user_id,
            content=old_content,
            message=f"Rollback to version {commit_sha[:7]}",
        )

    async def import_configuration(
        self,
        user_id: UUID,
        content: str,
    ) -> UserConfiguration:
        """
        Import configuration from uploaded file content.

        Same as save_configuration but with different commit message.
        """
        return await self.save_configuration(
            user_id=user_id,
            content=content,
            message="Import configuration from local file",
        )
```

Update application/services/__init__.py:
```python
from atlas.application.services.configuration_service import (
    ConfigurationService,
    ConfigurationNotFoundError,
    VersionNotFoundError,
)

__all__ = [
    "ConfigurationService",
    "ConfigurationNotFoundError",
    "VersionNotFoundError",
]
```
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "from atlas.application.services import ConfigurationService; print('OK')"
```
  </verify>
  <done>ConfigurationService exists with get_configuration, save_configuration, get_version_history, rollback_to_version, import_configuration methods</done>
</task>

<task type="auto">
  <name>Task 2: Add dependency injection for ConfigurationService</name>
  <files>
    backend/src/atlas/entrypoints/dependencies.py
  </files>
  <action>
Add configuration service dependencies to dependencies.py:

1. Add imports at top:
```python
from atlas.adapters.postgresql.repositories import PostgresConfigurationRepository
from atlas.application.services import ConfigurationService
from atlas.domain.interfaces import AbstractConfigurationRepository
```

2. Add configuration repository provider (after get_catalog_repository):
```python
async def get_configuration_repository(
    session: Annotated[AsyncSession, Depends(get_session)]
) -> AbstractConfigurationRepository:
    """Provide configuration repository implementation."""
    return PostgresConfigurationRepository(session)
```

3. Add configuration service provider (after get_sync_service):
```python
async def get_configuration_service(
    config_repo: Annotated[AbstractConfigurationRepository, Depends(get_configuration_repository)],
    content_repo: Annotated[AbstractContentRepository, Depends(get_content_repository)],
) -> ConfigurationService:
    """Provide configuration service implementation."""
    return ConfigurationService(config_repo, content_repo)
```

4. Add type aliases (after SyncService):
```python
ConfigRepo = Annotated[AbstractConfigurationRepository, Depends(get_configuration_repository)]
ConfigService = Annotated[ConfigurationService, Depends(get_configuration_service)]
```
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "from atlas.entrypoints.dependencies import ConfigService, ConfigRepo, get_configuration_service; print('OK')"
```
  </verify>
  <done>ConfigService and ConfigRepo type aliases exist; get_configuration_service provider defined</done>
</task>

<task type="auto">
  <name>Task 3: Create configuration API routes and register router</name>
  <files>
    backend/src/atlas/entrypoints/api/routes/configuration.py
    backend/src/atlas/entrypoints/api/routes/__init__.py
    backend/src/atlas/entrypoints/app.py
  </files>
  <action>
1. Create configuration.py routes:

```python
"""Configuration routes - Manage user's claude.md configuration."""

from datetime import datetime
from typing import Optional

from fastapi import APIRouter, HTTPException, Query, UploadFile, status
from pydantic import BaseModel

from atlas.application.services import ConfigurationNotFoundError, VersionNotFoundError
from atlas.entrypoints.dependencies import ConfigService, CurrentUser

router = APIRouter(prefix="/configuration", tags=["configuration"])


class ConfigurationResponse(BaseModel):
    """Response containing configuration content and metadata."""
    content: str
    commit_sha: str
    updated_at: datetime


class ConfigurationUpdateRequest(BaseModel):
    """Request to update configuration content."""
    content: str
    message: Optional[str] = None  # Optional custom commit message


class VersionResponse(BaseModel):
    """Single version in history."""
    commit_sha: str
    message: str
    author: str
    timestamp: datetime


class VersionHistoryResponse(BaseModel):
    """Version history response."""
    versions: list[VersionResponse]
    total: int


@router.get("/me", response_model=ConfigurationResponse)
async def get_my_configuration(
    current_user: CurrentUser,
    config_service: ConfigService,
) -> ConfigurationResponse:
    """
    Get current user's configuration.

    Returns empty content if user has not created a configuration yet.
    """
    content, config = await config_service.get_configuration(current_user.id)
    return ConfigurationResponse(
        content=content,
        commit_sha=config.current_commit_sha,
        updated_at=config.updated_at,
    )


@router.put("/me", response_model=ConfigurationResponse)
async def update_my_configuration(
    body: ConfigurationUpdateRequest,
    current_user: CurrentUser,
    config_service: ConfigService,
) -> ConfigurationResponse:
    """
    Update current user's configuration.

    Creates a new git commit with the updated content.
    Optionally accepts a custom commit message.
    """
    config = await config_service.save_configuration(
        user_id=current_user.id,
        content=body.content,
        message=body.message,
    )

    return ConfigurationResponse(
        content=body.content,
        commit_sha=config.current_commit_sha,
        updated_at=config.updated_at,
    )


@router.get("/me/history", response_model=VersionHistoryResponse)
async def get_configuration_history(
    current_user: CurrentUser,
    config_service: ConfigService,
    limit: int = Query(default=50, ge=1, le=100, description="Max versions to return"),
) -> VersionHistoryResponse:
    """
    Get version history of user's configuration.

    Returns list of all commits (versions) for the configuration file.
    """
    versions = await config_service.get_version_history(
        user_id=current_user.id,
        limit=limit,
    )

    return VersionHistoryResponse(
        versions=[
            VersionResponse(
                commit_sha=v.commit_sha,
                message=v.message,
                author=v.author,
                timestamp=v.timestamp,
            )
            for v in versions
        ],
        total=len(versions),
    )


@router.post("/me/rollback/{commit_sha}", response_model=ConfigurationResponse)
async def rollback_configuration(
    commit_sha: str,
    current_user: CurrentUser,
    config_service: ConfigService,
) -> ConfigurationResponse:
    """
    Rollback configuration to a previous version.

    Creates a new commit with the content from the specified version.
    """
    try:
        config = await config_service.rollback_to_version(
            user_id=current_user.id,
            commit_sha=commit_sha,
        )
    except ConfigurationNotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No configuration found for user",
        )
    except VersionNotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Version {commit_sha} not found",
        )

    # Get the rolled-back content
    content, _ = await config_service.get_configuration(current_user.id)

    return ConfigurationResponse(
        content=content,
        commit_sha=config.current_commit_sha,
        updated_at=config.updated_at,
    )


@router.post("/me/import", response_model=ConfigurationResponse)
async def import_configuration(
    file: UploadFile,
    current_user: CurrentUser,
    config_service: ConfigService,
) -> ConfigurationResponse:
    """
    Import configuration from uploaded .md file.

    Accepts a markdown file and saves it as the user's configuration.
    """
    # Validate file type
    if not file.filename or not file.filename.endswith(".md"):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File must be a .md file",
        )

    # Read and validate content
    content_bytes = await file.read()

    # Check file size (1MB limit)
    if len(content_bytes) > 1024 * 1024:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File size must be less than 1MB",
        )

    try:
        content_str = content_bytes.decode("utf-8")
    except UnicodeDecodeError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File must be valid UTF-8 text",
        )

    # Save via service
    config = await config_service.import_configuration(
        user_id=current_user.id,
        content=content_str,
    )

    return ConfigurationResponse(
        content=content_str,
        commit_sha=config.current_commit_sha,
        updated_at=config.updated_at,
    )
```

2. Update routes/__init__.py to export configuration_router:
```python
from atlas.entrypoints.api.routes.configuration import router as configuration_router
# Add to __all__ list
```

3. Update app.py to include configuration_router:
```python
# Add import
from atlas.entrypoints.api.routes import configuration_router

# Add router registration (after catalog_router)
app.include_router(configuration_router, prefix="/api/v1")
```
  </action>
  <verify>
```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.entrypoints.app import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
config_routes = [r for r in routes if 'configuration' in r]
print('Configuration routes:', config_routes)
"
```
  </verify>
  <done>All 5 configuration endpoints registered: GET/PUT /me, GET /me/history, POST /me/rollback/{sha}, POST /me/import</done>
</task>

</tasks>

<verification>
Complete API layer functional:

```bash
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.entrypoints.app import app

# Get all configuration routes
routes = []
for route in app.routes:
    if hasattr(route, 'path') and 'configuration' in route.path:
        methods = getattr(route, 'methods', set())
        routes.append((route.path, methods))

print('Configuration routes:')
for path, methods in sorted(routes):
    print(f'  {methods} {path}')

# Verify service imports
from atlas.application.services import ConfigurationService
from atlas.entrypoints.dependencies import ConfigService, ConfigRepo
print('\\nService and dependencies OK')
"
```
</verification>

<success_criteria>
- ConfigurationService has methods: get_configuration, save_configuration, get_version_history, rollback_to_version, import_configuration
- Dependency injection provides ConfigService and ConfigRepo type aliases
- GET /api/v1/configuration/me returns configuration content and metadata
- PUT /api/v1/configuration/me saves content to git and database
- GET /api/v1/configuration/me/history returns version history
- POST /api/v1/configuration/me/rollback/{sha} rolls back to previous version
- POST /api/v1/configuration/me/import accepts file upload
- All endpoints require authentication (CurrentUser)
</success_criteria>

<output>
After completion, create `.planning/phases/04-configuration-backend/04-03-SUMMARY.md`
</output>
