---
phase: 08-cli-sync-tool
plan: 05
type: execute
wave: 3
depends_on: ["08-03", "08-04"]
files_modified:
  - cli/tests/test_storage.py
  - cli/tests/test_commands.py
  - cli/src/atlas_cli/storage/credentials.py
  - cli/README.md
autonomous: true

must_haves:
  truths:
    - "Tests exist for credential storage"
    - "Tests exist for atomic file write"
    - "Tests exist for commands"
    - "CLI handles missing keyring gracefully"
    - "README documents installation and usage"
  artifacts:
    - path: "cli/tests/test_storage.py"
      provides: "Unit tests for storage modules"
    - path: "cli/tests/test_commands.py"
      provides: "Unit tests for CLI commands"
    - path: "cli/README.md"
      provides: "Installation and usage documentation"
  key_links:
    - from: "cli/tests/test_storage.py"
      to: "cli/src/atlas_cli/storage/credentials.py"
      via: "tests credential storage"
      pattern: "test_.*credentials"
    - from: "cli/tests/test_storage.py"
      to: "cli/src/atlas_cli/storage/files.py"
      via: "tests atomic write"
      pattern: "test_atomic_write"
---

<objective>
Add tests for cross-platform reliability and create documentation.

Purpose: Ensure the CLI works reliably across platforms and edge cases. Document installation and usage for users.
Output: Test suite and README documentation.
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-cli-sync-tool/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage tests</name>
  <files>
    cli/tests/test_storage.py
    cli/tests/__init__.py
  </files>
  <action>
    Create tests for storage modules:

    Create `cli/tests/__init__.py` (empty file).

    Create `cli/tests/test_storage.py`:

    ```python
    """Tests for storage modules."""

    import os
    import tempfile
    from pathlib import Path
    from unittest.mock import patch, MagicMock

    import pytest

    from atlas_cli.storage.files import atomic_write, get_claude_dir, get_config_path, read_config


    class TestAtomicWrite:
        """Tests for atomic file write."""

        def test_atomic_write_creates_file(self, tmp_path: Path) -> None:
            """atomic_write creates file with correct content."""
            test_file = tmp_path / "test.md"
            content = "# Test Content\n\nHello, World!"

            atomic_write(test_file, content)

            assert test_file.exists()
            assert test_file.read_text(encoding="utf-8") == content

        def test_atomic_write_creates_parent_dirs(self, tmp_path: Path) -> None:
            """atomic_write creates parent directories if needed."""
            test_file = tmp_path / "nested" / "dir" / "test.md"
            content = "Nested content"

            atomic_write(test_file, content)

            assert test_file.exists()
            assert test_file.read_text(encoding="utf-8") == content

        def test_atomic_write_overwrites_existing(self, tmp_path: Path) -> None:
            """atomic_write overwrites existing file."""
            test_file = tmp_path / "test.md"
            test_file.write_text("old content")

            atomic_write(test_file, "new content")

            assert test_file.read_text(encoding="utf-8") == "new content"

        def test_atomic_write_no_partial_on_error(self, tmp_path: Path) -> None:
            """atomic_write leaves no partial file on write error."""
            test_file = tmp_path / "test.md"
            test_file.write_text("original")

            # Simulate write failure by making the content raise during write
            with patch("os.fdopen") as mock_fdopen:
                mock_file = MagicMock()
                mock_file.__enter__ = MagicMock(return_value=mock_file)
                mock_file.__exit__ = MagicMock(return_value=False)
                mock_file.write.side_effect = IOError("Simulated write failure")
                mock_fdopen.return_value = mock_file

                with pytest.raises(IOError):
                    atomic_write(test_file, "new content that fails")

            # Original file should be unchanged
            assert test_file.read_text(encoding="utf-8") == "original"

        def test_atomic_write_handles_unicode(self, tmp_path: Path) -> None:
            """atomic_write handles unicode content correctly."""
            test_file = tmp_path / "test.md"
            content = "# Unicode Test\n\næ—¥æœ¬èªž emoji ðŸŽ‰ special chars: Ã¤Ã¶Ã¼"

            atomic_write(test_file, content)

            assert test_file.read_text(encoding="utf-8") == content


    class TestPaths:
        """Tests for path utilities."""

        def test_get_claude_dir_returns_path(self) -> None:
            """get_claude_dir returns Path object."""
            result = get_claude_dir()
            assert isinstance(result, Path)
            assert result.name == ".claude"

        def test_get_claude_dir_is_in_home(self) -> None:
            """get_claude_dir is under home directory."""
            result = get_claude_dir()
            assert result.parent == Path.home()

        def test_get_config_path_returns_claude_md(self) -> None:
            """get_config_path returns CLAUDE.md path."""
            result = get_config_path()
            assert result.name == "CLAUDE.md"
            assert result.parent == get_claude_dir()


    class TestReadConfig:
        """Tests for read_config."""

        def test_read_config_returns_content(self, tmp_path: Path) -> None:
            """read_config returns file content when exists."""
            with patch("atlas_cli.storage.files.get_config_path") as mock_path:
                test_file = tmp_path / "CLAUDE.md"
                test_file.write_text("test content")
                mock_path.return_value = test_file

                result = read_config()

                assert result == "test content"

        def test_read_config_returns_none_when_missing(self, tmp_path: Path) -> None:
            """read_config returns None when file doesn't exist."""
            with patch("atlas_cli.storage.files.get_config_path") as mock_path:
                mock_path.return_value = tmp_path / "nonexistent.md"

                result = read_config()

                assert result is None
    ```
  </action>
  <verify>
    cd cli && uv run pytest tests/test_storage.py -v
  </verify>
  <done>
    Storage tests pass for atomic write and path utilities
  </done>
</task>

<task type="auto">
  <name>Task 2: Add keyring fallback handling</name>
  <files>
    cli/src/atlas_cli/storage/credentials.py
  </files>
  <action>
    Update credentials.py to handle missing keyring backend gracefully:

    Add at the top of the file:
    ```python
    import sys
    from typing import Optional

    import keyring
    from keyring.errors import KeyringError, PasswordDeleteError

    SERVICE_NAME = "atlas-cli"

    def _check_keyring_available() -> bool:
        """Check if a working keyring backend is available."""
        try:
            backend = keyring.get_keyring()
            backend_name = type(backend).__name__
            # These backends don't actually store credentials
            return "Fail" not in backend_name and "Null" not in backend_name
        except Exception:
            return False
    ```

    Update save_tokens to handle errors:
    ```python
    def save_tokens(access_token: str, refresh_token: str) -> None:
        """Store tokens in system keychain."""
        try:
            keyring.set_password(SERVICE_NAME, "access_token", access_token)
            keyring.set_password(SERVICE_NAME, "refresh_token", refresh_token)
        except KeyringError as e:
            # On headless systems, keyring may not work
            raise RuntimeError(
                f"Failed to store credentials in keyring: {e}\n"
                "If you're on a headless system, consider using ATLAS_ACCESS_TOKEN environment variable."
            ) from e
    ```

    Add environment variable fallback to get_access_token:
    ```python
    def get_access_token() -> Optional[str]:
        """Retrieve access token from keychain or environment."""
        # Environment variable takes precedence (for CI/headless systems)
        env_token = os.environ.get("ATLAS_ACCESS_TOKEN")
        if env_token:
            return env_token

        try:
            return keyring.get_password(SERVICE_NAME, "access_token")
        except KeyringError:
            return None
    ```

    Don't forget to add `import os` at the top.
  </action>
  <verify>
    python -c "from atlas_cli.storage.credentials import get_access_token; print('OK')"
  </verify>
  <done>
    Credentials module handles missing keyring and supports ATLAS_ACCESS_TOKEN env var
  </done>
</task>

<task type="auto">
  <name>Task 3: Create command tests</name>
  <files>
    cli/tests/test_commands.py
  </files>
  <action>
    Create tests for CLI commands:

    Create `cli/tests/test_commands.py`:

    ```python
    """Tests for CLI commands."""

    from unittest.mock import patch, MagicMock
    from typer.testing import CliRunner

    from atlas_cli.main import app

    runner = CliRunner()


    class TestAuthCommands:
        """Tests for auth commands."""

        def test_auth_status_not_logged_in(self) -> None:
            """auth status shows not logged in when no token."""
            with patch("atlas_cli.commands.auth.is_authenticated", return_value=False):
                result = runner.invoke(app, ["auth", "status"])

                assert result.exit_code == 0
                assert "Not logged in" in result.output

        def test_auth_status_logged_in(self) -> None:
            """auth status shows authenticated when token exists."""
            with patch("atlas_cli.commands.auth.is_authenticated", return_value=True):
                result = runner.invoke(app, ["auth", "status"])

                assert result.exit_code == 0
                assert "Authenticated" in result.output

        def test_auth_logout_clears_tokens(self) -> None:
            """auth logout calls clear_tokens."""
            with patch("atlas_cli.commands.auth.clear_tokens") as mock_clear:
                result = runner.invoke(app, ["auth", "logout"])

                assert result.exit_code == 0
                mock_clear.assert_called_once()


    class TestSyncCommand:
        """Tests for sync command."""

        def test_sync_requires_auth(self) -> None:
            """sync shows error when not authenticated."""
            with patch("atlas_cli.commands.sync.is_authenticated", return_value=False):
                result = runner.invoke(app, ["sync"])

                assert result.exit_code == 1
                assert "Not logged in" in result.output

        def test_sync_dry_run(self) -> None:
            """sync --dry-run shows preview without writing."""
            mock_response = MagicMock()
            mock_response.json.return_value = {
                "content": "# Test config",
                "commit_sha": "abc1234567890"
            }
            mock_response.raise_for_status = MagicMock()

            mock_client = MagicMock()
            mock_client.__enter__ = MagicMock(return_value=mock_client)
            mock_client.__exit__ = MagicMock(return_value=False)
            mock_client.get.return_value = mock_response

            with patch("atlas_cli.commands.sync.is_authenticated", return_value=True):
                with patch("atlas_cli.commands.sync.create_client", return_value=mock_client):
                    with patch("atlas_cli.commands.sync.read_config", return_value=None):
                        result = runner.invoke(app, ["sync", "--dry-run"])

                        assert result.exit_code == 0
                        assert "Dry Run" in result.output


    class TestDoctorCommand:
        """Tests for doctor command."""

        def test_doctor_shows_checks(self) -> None:
            """doctor shows health check table."""
            with patch("atlas_cli.commands.doctor.is_authenticated", return_value=True):
                with patch("atlas_cli.commands.doctor.get_claude_dir") as mock_dir:
                    mock_dir.return_value = MagicMock(exists=MagicMock(return_value=True))
                    with patch("atlas_cli.commands.doctor.get_config_path") as mock_path:
                        mock_path_obj = MagicMock()
                        mock_path_obj.exists.return_value = True
                        mock_path_obj.stat.return_value = MagicMock(st_size=100)
                        mock_path.return_value = mock_path_obj
                        with patch("httpx.get") as mock_get:
                            mock_get.return_value = MagicMock(status_code=200)

                            result = runner.invoke(app, ["doctor"])

                            assert "Health Check" in result.output


    class TestHelpOutput:
        """Tests for help output."""

        def test_main_help(self) -> None:
            """Main help shows available commands."""
            result = runner.invoke(app, ["--help"])

            assert result.exit_code == 0
            assert "auth" in result.output
            assert "sync" in result.output
            assert "doctor" in result.output
            assert "status" in result.output

        def test_version(self) -> None:
            """--version shows version."""
            result = runner.invoke(app, ["--version"])

            assert result.exit_code == 0
            assert "atlas-cli" in result.output
    ```
  </action>
  <verify>
    cd cli && uv run pytest tests/test_commands.py -v
  </verify>
  <done>
    Command tests pass for auth, sync, doctor, and help output
  </done>
</task>

<task type="auto">
  <name>Task 4: Create README documentation</name>
  <files>
    cli/README.md
  </files>
  <action>
    Create CLI documentation:

    Create `cli/README.md`:

    ```markdown
    # Atlas CLI

    Command-line tool to sync Claude configuration from the Atlas platform to your local `~/.claude/` directory.

    ## Installation

    ```bash
    # From the cli directory
    cd cli
    uv sync
    uv pip install -e .
    ```

    ## Usage

    ### Authentication

    ```bash
    # Log in to Atlas
    atlas auth login

    # Check authentication status
    atlas auth status

    # Log out
    atlas auth logout
    ```

    ### Syncing Configuration

    ```bash
    # Sync configuration from Atlas to ~/.claude/CLAUDE.md
    atlas sync

    # Preview what would be synced (dry run)
    atlas sync --dry-run

    # Force sync even if local file exists
    atlas sync --force
    ```

    ### Status and Diagnostics

    ```bash
    # Quick sync status (local vs remote)
    atlas status

    # Full health check
    atlas doctor
    ```

    ## Configuration

    ### API URL

    By default, the CLI connects to `http://localhost:8000/api/v1`. Override with:

    ```bash
    export ATLAS_API_URL=https://atlas.yourcompany.com/api/v1
    ```

    ### CI/Headless Systems

    On systems without a graphical keyring (CI, servers), use environment variables:

    ```bash
    export ATLAS_ACCESS_TOKEN=your_token_here
    atlas sync
    ```

    ## Troubleshooting

    ### "No recommended backend" error

    This means keyring can't find a secure storage backend. Options:

    1. Install a keyring backend (e.g., `secretstorage` on Linux)
    2. Use `ATLAS_ACCESS_TOKEN` environment variable

    ### Network errors

    Run `atlas doctor` to check connectivity to the Atlas API.

    ## Development

    ```bash
    # Install dev dependencies
    uv sync --dev

    # Run tests
    uv run pytest

    # Run CLI in development
    uv run atlas --help
    ```
    ```
  </action>
  <verify>
    cat cli/README.md | head -20
  </verify>
  <done>
    README documents installation, usage, configuration, and troubleshooting
  </done>
</task>

</tasks>

<verification>
All checks pass:
- `cd cli && uv run pytest` - all tests pass
- `atlas --help` shows all commands
- `atlas doctor` runs health checks
- README provides complete documentation
</verification>

<success_criteria>
1. Storage tests verify atomic write behavior
2. Command tests verify CLI behavior with mocks
3. Keyring fallback supports ATLAS_ACCESS_TOKEN env var
4. README documents installation and usage
5. Troubleshooting section covers common issues
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-cli-sync-tool/08-05-SUMMARY.md`
</output>
