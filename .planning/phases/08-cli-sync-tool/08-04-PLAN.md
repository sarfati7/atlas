---
phase: 08-cli-sync-tool
plan: 04
type: execute
wave: 3
depends_on: ["08-03"]
files_modified:
  - cli/src/atlas_cli/commands/doctor.py
  - cli/src/atlas_cli/commands/status.py
  - cli/src/atlas_cli/main.py
autonomous: true

must_haves:
  truths:
    - "User can run 'atlas doctor' to check CLI health"
    - "Doctor shows authentication, connectivity, and config status"
    - "User can run 'atlas status' for quick sync status"
    - "Status shows local vs remote comparison"
  artifacts:
    - path: "cli/src/atlas_cli/commands/doctor.py"
      provides: "Health check command with table output"
      exports: ["doctor"]
    - path: "cli/src/atlas_cli/commands/status.py"
      provides: "Quick status command"
      exports: ["status"]
  key_links:
    - from: "cli/src/atlas_cli/commands/doctor.py"
      to: "cli/src/atlas_cli/storage/credentials.py"
      via: "checks authentication"
      pattern: "is_authenticated"
    - from: "cli/src/atlas_cli/commands/doctor.py"
      to: "cli/src/atlas_cli/api/client.py"
      via: "checks API connectivity"
      pattern: "create_client"
---

<objective>
Implement doctor and status commands for diagnostics and quick status checks.

Purpose: Users need to troubleshoot issues and quickly check if their local config is in sync with Atlas.
Output: Working `atlas doctor` and `atlas status` commands.
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-cli-sync-tool/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create doctor command</name>
  <files>
    cli/src/atlas_cli/commands/doctor.py
  </files>
  <action>
    Create health check command with Rich table output:

    Create `cli/src/atlas_cli/commands/doctor.py`:

    ```python
    """Doctor command - health check for Atlas CLI."""

    import httpx
    import typer
    from rich.table import Table

    from atlas_cli.config import config
    from atlas_cli.console import console
    from atlas_cli.storage.credentials import is_authenticated, get_access_token
    from atlas_cli.storage.files import get_claude_dir, get_config_path


    def doctor() -> None:
        """Check CLI configuration and connectivity."""
        table = Table(title="Atlas CLI Health Check")
        table.add_column("Check", style="cyan")
        table.add_column("Status")
        table.add_column("Details")

        all_ok = True

        # Check 1: Authentication
        if is_authenticated():
            table.add_row("Authentication", "[green]OK[/green]", "Token stored in keychain")
        else:
            table.add_row("Authentication", "[red]FAIL[/red]", "Not logged in - run 'atlas auth login'")
            all_ok = False

        # Check 2: Config directory
        config_dir = get_claude_dir()
        if config_dir.exists():
            table.add_row("Config Directory", "[green]OK[/green]", str(config_dir))
        else:
            table.add_row("Config Directory", "[yellow]MISSING[/yellow]", f"{config_dir} - will be created on sync")

        # Check 3: Config file
        config_path = get_config_path()
        if config_path.exists():
            size = config_path.stat().st_size
            table.add_row("Config File", "[green]OK[/green]", f"{config_path} ({size} bytes)")
        else:
            table.add_row("Config File", "[yellow]MISSING[/yellow]", f"{config_path} - run 'atlas sync'")

        # Check 4: API connectivity
        try:
            # Use unauthenticated request to health endpoint or just base URL
            response = httpx.get(
                f"{config.api_base_url.rstrip('/api/v1')}/health",
                timeout=5.0,
            )
            if response.status_code == 200:
                table.add_row("API Connectivity", "[green]OK[/green]", config.api_base_url)
            else:
                table.add_row("API Connectivity", "[yellow]DEGRADED[/yellow]", f"Status {response.status_code}")
                all_ok = False
        except httpx.RequestError as e:
            table.add_row("API Connectivity", "[red]FAIL[/red]", f"Cannot reach API: {type(e).__name__}")
            all_ok = False

        # Check 5: Keyring backend
        try:
            import keyring
            backend = keyring.get_keyring()
            backend_name = type(backend).__name__
            if "Fail" in backend_name or "Null" in backend_name:
                table.add_row("Keyring Backend", "[yellow]WARN[/yellow]", f"{backend_name} - credentials may not persist")
            else:
                table.add_row("Keyring Backend", "[green]OK[/green]", backend_name)
        except Exception as e:
            table.add_row("Keyring Backend", "[red]FAIL[/red]", str(e))
            all_ok = False

        console.print(table)

        # Summary
        console.print()
        if all_ok:
            console.print("[green]All checks passed![/green]")
        else:
            console.print("[yellow]Some issues found. See above for details.[/yellow]")
            raise typer.Exit(1)
    ```
  </action>
  <verify>
    python -c "from atlas_cli.commands.doctor import doctor; print('doctor command loaded')"
  </verify>
  <done>
    Doctor command checks auth, connectivity, config, and keyring backend
  </done>
</task>

<task type="auto">
  <name>Task 2: Create status command</name>
  <files>
    cli/src/atlas_cli/commands/status.py
  </files>
  <action>
    Create quick status check command:

    Create `cli/src/atlas_cli/commands/status.py`:

    ```python
    """Status command - quick sync status check."""

    import typer

    from atlas_cli.api.client import create_client
    from atlas_cli.console import console, error, info
    from atlas_cli.storage.credentials import is_authenticated
    from atlas_cli.storage.files import get_config_path, read_config


    def status() -> None:
        """Show sync status - compare local config with remote."""
        config_path = get_config_path()

        # Check local config
        local_content = read_config()
        local_exists = local_content is not None

        console.print("[bold]Atlas Sync Status[/bold]\n")

        # Local status
        if local_exists:
            local_size = len(local_content) if local_content else 0
            console.print(f"[cyan]Local:[/cyan]  {config_path} ({local_size} bytes)")
        else:
            console.print(f"[cyan]Local:[/cyan]  {config_path} [yellow](not found)[/yellow]")

        # Check if authenticated for remote status
        if not is_authenticated():
            console.print(f"[cyan]Remote:[/cyan] [dim]Login required to check remote status[/dim]")
            info("\nRun 'atlas auth login' to authenticate.")
            return

        # Fetch remote status
        try:
            with console.status("Checking remote..."):
                with create_client() as client:
                    response = client.get("/configuration/me")
                    response.raise_for_status()

                data = response.json()
                remote_content = data.get("content", "")
                remote_sha = data.get("commit_sha", "unknown")

            if remote_content:
                console.print(f"[cyan]Remote:[/cyan] {len(remote_content)} bytes (commit: {remote_sha[:7]})")
            else:
                console.print(f"[cyan]Remote:[/cyan] [yellow](no configuration)[/yellow]")

            # Compare
            console.print()
            if not remote_content:
                console.print("[yellow]No remote configuration. Create one in Atlas web UI.[/yellow]")
            elif not local_exists:
                console.print("[yellow]Local config missing. Run 'atlas sync' to download.[/yellow]")
            elif local_content == remote_content:
                console.print("[green]In sync[/green] - local matches remote")
            else:
                console.print("[yellow]Out of sync[/yellow] - local differs from remote")
                console.print("Run 'atlas sync' to update local config")

        except Exception as e:
            console.print(f"[cyan]Remote:[/cyan] [red]Error: {e}[/red]")
    ```
  </action>
  <verify>
    python -c "from atlas_cli.commands.status import status; print('status command loaded')"
  </verify>
  <done>
    Status command compares local vs remote configuration
  </done>
</task>

<task type="auto">
  <name>Task 3: Register commands in main.py</name>
  <files>
    cli/src/atlas_cli/main.py
  </files>
  <action>
    Update `cli/src/atlas_cli/main.py` to register doctor and status commands:

    Add imports:
    ```python
    from atlas_cli.commands.doctor import doctor
    from atlas_cli.commands.status import status
    ```

    Add command registrations:
    ```python
    app.command()(doctor)
    app.command()(status)
    ```

    Final main.py should have:
    - auth group (from 08-02)
    - sync command (from 08-03)
    - doctor command
    - status command
  </action>
  <verify>
    atlas --help
  </verify>
  <done>
    `atlas --help` shows all commands: auth, sync, doctor, status
  </done>
</task>

</tasks>

<verification>
All checks pass:
- `atlas doctor` shows health check table with 5 checks
- `atlas status` shows local vs remote comparison
- Both commands handle unauthenticated state gracefully
- Doctor returns exit code 1 if any checks fail
</verification>

<success_criteria>
1. Doctor command checks authentication, connectivity, config directory, config file, keyring backend
2. Doctor shows Rich table with status indicators (OK/FAIL/WARN)
3. Status command shows local and remote config info
4. Status compares content and reports sync state
5. Both commands work without authentication (with limited functionality)
6. Commands registered and visible in `atlas --help`
</success_criteria>

<output>
After completion, create `.planning/phases/08-cli-sync-tool/08-04-SUMMARY.md`
</output>
