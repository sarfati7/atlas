---
phase: 08-cli-sync-tool
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - cli/src/atlas_cli/config.py
  - cli/src/atlas_cli/api/__init__.py
  - cli/src/atlas_cli/api/client.py
  - cli/src/atlas_cli/api/auth.py
  - cli/src/atlas_cli/commands/auth.py
  - cli/src/atlas_cli/main.py
autonomous: true

must_haves:
  truths:
    - "User can login with email and password"
    - "Access token and refresh token are stored in OS keychain"
    - "User can logout (tokens cleared)"
    - "User can check auth status"
  artifacts:
    - path: "cli/src/atlas_cli/config.py"
      provides: "Configuration with API base URL"
      exports: ["config"]
    - path: "cli/src/atlas_cli/api/client.py"
      provides: "Configured httpx client factory"
      exports: ["create_client"]
    - path: "cli/src/atlas_cli/api/auth.py"
      provides: "Custom httpx.Auth for token refresh"
      exports: ["TokenAuth"]
    - path: "cli/src/atlas_cli/commands/auth.py"
      provides: "Login, logout, status commands"
      exports: ["app"]
  key_links:
    - from: "cli/src/atlas_cli/commands/auth.py"
      to: "cli/src/atlas_cli/api/client.py"
      via: "login makes HTTP request"
      pattern: "httpx.post"
    - from: "cli/src/atlas_cli/commands/auth.py"
      to: "cli/src/atlas_cli/storage/credentials.py"
      via: "stores tokens after login"
      pattern: "save_tokens"
    - from: "cli/src/atlas_cli/main.py"
      to: "cli/src/atlas_cli/commands/auth.py"
      via: "registers auth command group"
      pattern: "app.add_typer"
---

<objective>
Implement API client with token authentication and auth commands (login, logout, status).

Purpose: Enable users to authenticate with the Atlas platform and securely store credentials for subsequent commands.
Output: Working `atlas auth login`, `atlas auth logout`, and `atlas auth status` commands.
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-cli-sync-tool/08-RESEARCH.md
@.planning/phases/08-cli-sync-tool/08-01-SUMMARY.md
@backend/src/atlas/entrypoints/api/routes/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configuration and API client modules</name>
  <files>
    cli/src/atlas_cli/config.py
    cli/src/atlas_cli/api/client.py
    cli/src/atlas_cli/api/auth.py
  </files>
  <action>
    Create configuration and HTTP client infrastructure:

    1. Create `cli/src/atlas_cli/config.py`:
       - Import os
       - Define Config dataclass with:
         - api_base_url: str (default from env ATLAS_API_URL or "http://localhost:8000/api/v1")
         - timeout: float = 30.0
       - Create config = Config() singleton
       - Allow override via environment variable for production deployment

    2. Create `cli/src/atlas_cli/api/auth.py`:
       - Import httpx
       - Import get_access_token, get_refresh_token, save_tokens from storage.credentials

       - Implement TokenAuth(httpx.Auth) class:
         - Set requires_response_body = True (needed for refresh logic)
         - __init__: Load tokens from keyring (access_token, refresh_token)

         - auth_flow(self, request) generator:
           - If no access_token, yield request as-is (will get 401)
           - Set Authorization header: f"Bearer {self.access_token}"
           - response = yield request

           - If response.status_code == 401 and self.refresh_token:
             - Create refresh request to /auth/refresh with cookies
             - refresh_response = yield refresh_request
             - If 200: save new access_token, retry original request
             - Else: yield response (let caller handle auth failure)

    3. Create `cli/src/atlas_cli/api/client.py`:
       - Import httpx
       - Import config from config.py
       - Import TokenAuth from auth.py

       - Implement create_client() -> httpx.Client:
         - Return httpx.Client(
             base_url=config.api_base_url,
             auth=TokenAuth(),
             headers={"User-Agent": f"atlas-cli/{__version__}"},
             timeout=config.timeout,
           )

       - Implement create_unauthenticated_client() -> httpx.Client:
         - Same but without auth (for login endpoint)
  </action>
  <verify>
    python -c "from atlas_cli.config import config; from atlas_cli.api.client import create_unauthenticated_client; print(f'API: {config.api_base_url}')"
  </verify>
  <done>
    Config loads from environment, httpx clients can be created
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth commands (login, logout, status)</name>
  <files>
    cli/src/atlas_cli/commands/auth.py
    cli/src/atlas_cli/main.py
  </files>
  <action>
    Create authentication commands following the research patterns:

    1. Create `cli/src/atlas_cli/commands/auth.py`:
       - Import typer, httpx
       - Import console helpers from console.py
       - Import save_tokens, clear_tokens, is_authenticated from storage.credentials
       - Import config from config.py

       - Create app = typer.Typer(name="auth", help="Authentication commands")

       - Implement login command:
         @app.command()
         def login(
             email: str = typer.Option(..., prompt=True, help="Your Atlas email"),
             password: str = typer.Option(..., prompt=True, hide_input=True, help="Your password"),
         ):
           - Use console.status("Authenticating...") context manager
           - POST to {api_base_url}/auth/login with OAuth2 form data:
             data={"username": email, "password": password}
           - On 200: extract access_token from JSON, refresh_token from cookies
           - Call save_tokens(access_token, refresh_token)
           - Print success message
           - On 401: Print "Invalid email or password", raise typer.Exit(1)
           - On network error: Print friendly message, raise typer.Exit(1)

       - Implement logout command:
         @app.command()
         def logout():
           - Call clear_tokens()
           - Print success message

       - Implement status command:
         @app.command()
         def status():
           - If is_authenticated(): Print "Authenticated"
           - Else: Print "Not logged in" and hint to run "atlas auth login"

    2. Update `cli/src/atlas_cli/main.py`:
       - Import auth commands: from atlas_cli.commands import auth
       - Register auth command group: app.add_typer(auth.app, name="auth")
  </action>
  <verify>
    atlas auth --help && atlas auth status
  </verify>
  <done>
    `atlas auth login`, `atlas auth logout`, `atlas auth status` commands work
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration test with running backend</name>
  <files>
    None (verification only)
  </files>
  <action>
    Test the complete auth flow:

    1. Ensure backend is running (or use a test account if available)

    2. Run `atlas auth status` - should show "Not logged in"

    3. Run `atlas auth login` - enter valid credentials
       - Should show "Successfully logged in!"

    4. Run `atlas auth status` - should show "Authenticated"

    5. Run `atlas auth logout` - should show "Logged out successfully"

    6. Run `atlas auth status` - should show "Not logged in"

    If backend is not running, test with a mock or skip to verification summary.

    Note: This task verifies the integration works. If backend is unavailable,
    the commands should still work (just return network errors gracefully).
  </action>
  <verify>
    atlas auth status
  </verify>
  <done>
    Auth commands work correctly (status shows login state accurately)
  </done>
</task>

</tasks>

<verification>
All checks pass:
- `atlas auth login` prompts for email/password and stores tokens
- `atlas auth logout` clears stored tokens
- `atlas auth status` reports current authentication state
- Token refresh is handled transparently by TokenAuth class
</verification>

<success_criteria>
1. User can authenticate with email and password via CLI
2. Tokens stored securely in OS keychain (not plain text files)
3. Logout clears all stored credentials
4. Status command accurately reflects authentication state
5. Network errors show user-friendly messages (not tracebacks)
</success_criteria>

<output>
After completion, create `.planning/phases/08-cli-sync-tool/08-02-SUMMARY.md`
</output>
