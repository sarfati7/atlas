---
phase: 02-authentication
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/atlas/entrypoints/api/routes/auth.py
  - backend/src/atlas/entrypoints/dependencies.py
autonomous: true

must_haves:
  truths:
    - "User can log in with email and password"
    - "User receives access token on successful login"
    - "User stays logged in across browser sessions (refresh token in cookie)"
    - "User can log out from any page"
    - "Invalid credentials return generic error (no email enumeration)"
  artifacts:
    - path: "backend/src/atlas/entrypoints/api/routes/auth.py"
      provides: "Login, logout, refresh, and me endpoints"
      contains: "@router.post(\"/login\")"
    - path: "backend/src/atlas/entrypoints/dependencies.py"
      provides: "get_current_user dependency"
      contains: "async def get_current_user"
  key_links:
    - from: "routes/auth.py login"
      to: "jwt_auth_service.verify_password"
      via: "dependency injection"
      pattern: "auth_service.verify_password"
    - from: "routes/auth.py login"
      to: "response.set_cookie"
      via: "HttpOnly cookie for refresh token"
      pattern: "set_cookie.*refresh_token.*httponly=True"
    - from: "dependencies.py get_current_user"
      to: "jwt_auth_service.verify_token"
      via: "OAuth2PasswordBearer"
      pattern: "oauth2_scheme.*verify_token"
---

<objective>
Implement login, session management, and logout functionality.

Purpose: Enable users to authenticate and maintain sessions. Login returns access token for API calls; refresh token in HttpOnly cookie maintains sessions across browser restarts.

Output: Working login, logout, refresh, and /me endpoints with JWT-based session management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication/02-RESEARCH.md

# Depends on 02-01 output
@.planning/phases/02-authentication/02-01-SUMMARY.md

# Code to extend
@backend/src/atlas/entrypoints/api/routes/auth.py
@backend/src/atlas/entrypoints/dependencies.py
@backend/src/atlas/adapters/auth/jwt_auth_service.py
@backend/src/atlas/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_current_user dependency</name>
  <files>
    - backend/src/atlas/entrypoints/dependencies.py
  </files>
  <action>
1. Add OAuth2PasswordBearer import from fastapi.security

2. Create oauth2_scheme:
   - OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

3. Create get_current_user async dependency:
   - Parameters: token from oauth2_scheme, auth_service from get_auth_service, user_repo from get_user_repository
   - Call auth_service.verify_token(token) to get user_id
   - If None, raise HTTPException 401 with "Could not validate credentials" and WWW-Authenticate: Bearer header
   - Fetch user via user_repo.get_by_id(user_id)
   - If None, raise same 401 error
   - Return User entity

4. Create get_current_user_optional (for routes that work with or without auth):
   - Same logic but returns None instead of raising on invalid token
   - Useful for future routes

5. Add type aliases:
   - CurrentUser = Annotated[User, Depends(get_current_user)]
   - Rename existing AuthService (authorization) to AuthorizationSvc to avoid confusion
   - Add AuthenticationSvc = Annotated[AbstractAuthService, Depends(get_auth_service)]
  </action>
  <verify>
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.entrypoints.dependencies import get_current_user, oauth2_scheme, CurrentUser
print('get_current_user dependency created')
print('oauth2_scheme tokenUrl:', oauth2_scheme.model.flows.password.tokenUrl if hasattr(oauth2_scheme.model, 'flows') else 'configured')
"
  </verify>
  <done>
- OAuth2PasswordBearer configured with tokenUrl /api/v1/auth/login
- get_current_user dependency validates JWT and returns User
- CurrentUser type alias available for route signatures
- 401 returned for invalid/expired tokens
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement login, logout, refresh, and me endpoints</name>
  <files>
    - backend/src/atlas/entrypoints/api/routes/auth.py
  </files>
  <action>
1. Create response models:
   - TokenResponse(access_token: str, token_type: str = "bearer", expires_in: int)
   - UserResponse(id: UUID, email: str, username: str, created_at: datetime)

2. POST /login endpoint:
   - Use OAuth2PasswordRequestForm (username field = email)
   - Rate limit: @limiter.limit("5/minute")
   - Fetch user by email (form_data.username)
   - If not found OR password_hash is None: raise 401 "Incorrect email or password"
   - Verify password via auth_service.verify_password()
   - If fails: raise 401 "Incorrect email or password" (same message - no enumeration)
   - Create access_token via auth_service.create_access_token(user.id)
   - Create refresh_token via auth_service.create_refresh_token(user.id)
   - Set refresh_token in HttpOnly cookie:
     - key="refresh_token"
     - httponly=True
     - secure=settings.debug == False (True in prod)
     - samesite="lax" (allows redirect from email links)
     - max_age=7 * 24 * 60 * 60 (7 days)
     - path="/api/v1/auth" (only sent to auth endpoints)
   - Return TokenResponse with access_token

3. POST /logout endpoint:
   - Requires: current_user (CurrentUser dependency) - ensures only logged-in users can logout
   - Delete refresh_token cookie:
     - response.delete_cookie(key="refresh_token", path="/api/v1/auth")
   - Return {"message": "Logged out successfully"}

4. POST /refresh endpoint:
   - Get refresh_token from request.cookies
   - If missing: raise 401 "Refresh token missing"
   - Verify via auth_service.verify_token(refresh_token)
   - If invalid: raise 401 "Invalid refresh token"
   - Check token type is "refresh" (decode payload, check type field)
   - Fetch user to ensure still exists
   - Create new access_token
   - Return TokenResponse

5. GET /me endpoint:
   - Requires: current_user (CurrentUser dependency)
   - Return UserResponse with user data
  </action>
  <verify>
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.entrypoints.api.routes.auth import router
routes = {r.path: r.methods for r in router.routes if hasattr(r, 'methods')}
print('Auth routes:', routes)
assert '/login' in routes, 'login missing'
assert '/logout' in routes, 'logout missing'
assert '/refresh' in routes, 'refresh missing'
assert '/me' in routes, 'me missing'
print('All session endpoints created')
"
  </verify>
  <done>
- POST /login authenticates and returns access token + sets refresh cookie
- POST /logout clears refresh cookie
- POST /refresh exchanges refresh token for new access token
- GET /me returns current user info
- Same error message for wrong email vs wrong password
- Rate limiting on login (5/minute)
- Refresh token in HttpOnly secure cookie with proper settings
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Login flow:
   - POST /api/v1/auth/login with valid credentials returns access_token
   - Response sets refresh_token cookie
2. Protected routes:
   - GET /api/v1/auth/me with valid Bearer token returns user info
   - Without token returns 401
3. Refresh flow:
   - POST /api/v1/auth/refresh with valid cookie returns new access_token
4. Logout:
   - POST /api/v1/auth/logout clears cookie
</verification>

<success_criteria>
- User can log in with email and password (POST /login)
- Access token returned in response body
- Refresh token stored in HttpOnly cookie (7 day expiry)
- User can get their info (GET /me) with valid token
- User can refresh access token (POST /refresh) using cookie
- User can log out (POST /logout) which clears cookie
- Invalid credentials return generic error (no email enumeration)
- Login rate limited (5/minute)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-02-SUMMARY.md`
</output>
