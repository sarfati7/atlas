---
phase: 02-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/atlas/domain/entities/user.py
  - backend/src/atlas/domain/value_objects/password.py
  - backend/src/atlas/domain/interfaces/auth_service.py
  - backend/src/atlas/domain/interfaces/__init__.py
  - backend/src/atlas/adapters/auth/__init__.py
  - backend/src/atlas/adapters/auth/jwt_auth_service.py
  - backend/src/atlas/config.py
  - backend/src/atlas/entrypoints/api/routes/auth.py
  - backend/src/atlas/entrypoints/dependencies.py
  - backend/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "User can create account with email and password"
    - "Password is hashed before storage (never stored plain)"
    - "Registration rejects weak passwords (< 8 chars)"
    - "Registration rejects duplicate emails"
  artifacts:
    - path: "backend/src/atlas/domain/entities/user.py"
      provides: "User entity with password_hash field"
      contains: "password_hash: Optional[str]"
    - path: "backend/src/atlas/domain/value_objects/password.py"
      provides: "Password validation rules"
      exports: ["Password"]
    - path: "backend/src/atlas/domain/interfaces/auth_service.py"
      provides: "Abstract auth service contract"
      exports: ["AbstractAuthService"]
    - path: "backend/src/atlas/adapters/auth/jwt_auth_service.py"
      provides: "JWT implementation with Argon2 hashing"
      exports: ["JWTAuthService"]
    - path: "backend/src/atlas/entrypoints/api/routes/auth.py"
      provides: "POST /api/v1/auth/register endpoint"
      contains: "@router.post(\"/register\")"
  key_links:
    - from: "entrypoints/api/routes/auth.py"
      to: "adapters/auth/jwt_auth_service.py"
      via: "dependency injection"
      pattern: "auth_service.*hash_password"
    - from: "adapters/auth/jwt_auth_service.py"
      to: "pwdlib"
      via: "PasswordHash.recommended()"
      pattern: "PasswordHash"
---

<objective>
Implement user registration with secure password hashing using Argon2id.

Purpose: Enable users to create accounts securely. This is the foundation for all authentication - without registration, no login or password reset is possible.

Output: Working POST /api/v1/auth/register endpoint that creates users with hashed passwords.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication/02-RESEARCH.md

# Existing code to extend
@backend/src/atlas/domain/entities/user.py
@backend/src/atlas/domain/interfaces/user_repository.py
@backend/src/atlas/adapters/postgresql/models.py
@backend/src/atlas/config.py
@backend/src/atlas/entrypoints/dependencies.py
@backend/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth dependencies and domain layer</name>
  <files>
    - backend/pyproject.toml
    - backend/src/atlas/domain/entities/user.py
    - backend/src/atlas/domain/value_objects/password.py
    - backend/src/atlas/domain/interfaces/auth_service.py
    - backend/src/atlas/domain/interfaces/__init__.py
    - backend/src/atlas/config.py
  </files>
  <action>
1. Add auth dependencies to pyproject.toml:
   - pyjwt>=2.10.0
   - pwdlib[argon2]>=0.3.0
   - itsdangerous>=2.2.0
   - slowapi>=0.1.9

2. Update User entity (domain/entities/user.py):
   - Add `password_hash: Optional[str] = None` field
   - Keep existing fields unchanged

3. Create Password value object (domain/value_objects/password.py):
   - Pydantic BaseModel with single `value: str` field
   - @field_validator that enforces minimum 8 characters
   - Raise ValueError with clear message for invalid passwords

4. Create AbstractAuthService interface (domain/interfaces/auth_service.py):
   - Abstract methods: hash_password, verify_password, create_access_token, create_refresh_token, verify_token, create_password_reset_token, verify_password_reset_token
   - Follow pattern from 02-RESEARCH.md exactly
   - All methods take primitive types (str, UUID) not domain objects

5. Export AbstractAuthService from domain/interfaces/__init__.py

6. Update config.py Settings class:
   - Add `secret_key: str` with default for development (warn if default used)
   - Add `access_token_expire_minutes: int = 30`
   - Add `refresh_token_expire_days: int = 7`
   - Add `frontend_url: str = "http://localhost:3000"` (for password reset links)
  </action>
  <verify>
cd /Users/roysarfati/PycharmProjects/atlas/backend && uv sync && python -c "from atlas.domain.interfaces import AbstractAuthService; from atlas.domain.value_objects.password import Password; from atlas.config import settings; print('secret_key:', bool(settings.secret_key))"
  </verify>
  <done>
- pyproject.toml has pyjwt, pwdlib[argon2], itsdangerous, slowapi
- User entity has password_hash field
- Password value object validates minimum 8 chars
- AbstractAuthService interface exists with all methods
- config.py has secret_key and token expiry settings
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JWT auth service and registration endpoint</name>
  <files>
    - backend/src/atlas/adapters/auth/__init__.py
    - backend/src/atlas/adapters/auth/jwt_auth_service.py
    - backend/src/atlas/entrypoints/dependencies.py
    - backend/src/atlas/entrypoints/api/routes/auth.py
    - backend/src/atlas/entrypoints/api/routes/__init__.py
  </files>
  <action>
1. Create adapters/auth/__init__.py (empty, package marker)

2. Implement JWTAuthService (adapters/auth/jwt_auth_service.py):
   - Implement AbstractAuthService interface
   - Use pwdlib.PasswordHash.recommended() for Argon2id hashing
   - Use PyJWT for token creation/verification
   - Use itsdangerous.URLSafeTimedSerializer for password reset tokens
   - Constructor takes secret_key, algorithm="HS256", password_reset_salt="password-reset"
   - Follow exact implementation from 02-RESEARCH.md

3. Update entrypoints/dependencies.py:
   - Add get_auth_service() dependency returning JWTAuthService
   - Import from atlas.adapters.auth.jwt_auth_service
   - Create AuthenticationService type alias (avoid name collision with existing AuthService for authorization)

4. Create auth routes (entrypoints/api/routes/auth.py):
   - APIRouter with prefix="/auth", tags=["authentication"]
   - POST /register endpoint:
     - Request body: RegisterRequest(email: EmailStr, password: str, username: str)
     - Validate password using Password value object (raises 422 if < 8 chars)
     - Check email not already registered (get_by_email) - return 400 "Email already registered"
     - Check username not already taken (get_by_username) - return 400 "Username already taken"
     - Hash password via auth_service.hash_password()
     - Create User entity with password_hash
     - Save via user_repo.save()
     - Return 201 with {"message": "User created successfully", "user_id": str(user.id)}
   - Apply rate limiting: @limiter.limit("3/minute") using slowapi

5. Wire auth router in routes/__init__.py or main app (check existing pattern)
  </action>
  <verify>
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.adapters.auth.jwt_auth_service import JWTAuthService
from atlas.entrypoints.api.routes.auth import router
svc = JWTAuthService('test-secret')
hashed = svc.hash_password('testpassword123')
assert svc.verify_password('testpassword123', hashed), 'Password verification failed'
assert not svc.verify_password('wrongpassword', hashed), 'Wrong password should not verify'
print('Auth service works correctly')
print('Routes:', [r.path for r in router.routes])
"
  </verify>
  <done>
- JWTAuthService implements all AbstractAuthService methods
- Password hashing uses Argon2id via pwdlib
- POST /register endpoint exists with proper validation
- Rate limiting applied (3/minute)
- Registration returns 201 on success
- Registration returns 400 for duplicate email/username
- Registration returns 422 for password < 8 chars
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire auth router and test registration flow</name>
  <files>
    - backend/src/atlas/entrypoints/app.py (or main.py - check existing)
  </files>
  <action>
1. Find main FastAPI app file and include auth router:
   - Import router from atlas.entrypoints.api.routes.auth
   - Include with prefix="/api/v1"
   - Add slowapi limiter middleware if not present

2. Add slowapi setup:
   - Create Limiter instance with get_remote_address key function
   - Add SlowAPIMiddleware or exception handler
   - Store limiter in app.state for route access

3. Ensure app starts without errors:
   - All imports resolve
   - Router is accessible at /api/v1/auth/register
  </action>
  <verify>
cd /Users/roysarfati/PycharmProjects/atlas/backend && python -c "
from atlas.entrypoints.app import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
print('App routes:', routes)
assert any('/auth/register' in str(r) for r in routes), 'Register route not found'
print('Auth router wired correctly')
"
  </verify>
  <done>
- FastAPI app includes auth router at /api/v1/auth/*
- Rate limiter middleware configured
- App starts without import errors
- /api/v1/auth/register endpoint accessible
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd backend && uv sync` - dependencies install
2. `python -c "from atlas.entrypoints.app import app"` - app loads
3. Auth service hashes and verifies passwords correctly
4. Register endpoint exists at /api/v1/auth/register
</verification>

<success_criteria>
- User entity has password_hash field
- AbstractAuthService interface defined in domain layer
- JWTAuthService uses Argon2id for password hashing
- POST /api/v1/auth/register creates users with hashed passwords
- Registration validates: password length (8+), unique email, unique username
- Rate limiting protects registration endpoint (3/min)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-01-SUMMARY.md`
</output>
