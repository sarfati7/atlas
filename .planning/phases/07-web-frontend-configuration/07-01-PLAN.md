---
phase: 07-web-frontend-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/features/configuration/types.ts
  - frontend/src/features/configuration/api/configurationApi.ts
  - frontend/src/features/configuration/hooks/useConfiguration.ts
  - frontend/src/features/configuration/components/ConfigurationEditor.tsx
  - frontend/src/features/configuration/index.ts
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "Configuration API layer matches backend endpoints"
    - "Monaco editor renders with dark theme"
    - "User can toggle between edit and preview mode"
    - "Types match backend response shapes"
  artifacts:
    - path: "frontend/src/features/configuration/types.ts"
      provides: "TypeScript types matching backend"
      contains: "Configuration, ConfigurationUpdate, Version, VersionHistory"
    - path: "frontend/src/features/configuration/api/configurationApi.ts"
      provides: "API calls to backend"
      exports: ["configurationApi"]
    - path: "frontend/src/features/configuration/hooks/useConfiguration.ts"
      provides: "TanStack Query hooks"
      exports: ["useConfiguration", "useUpdateConfiguration", "useVersionHistory", "useRollback", "useImportConfiguration"]
    - path: "frontend/src/features/configuration/components/ConfigurationEditor.tsx"
      provides: "Monaco markdown editor with preview toggle"
      exports: ["ConfigurationEditor"]
  key_links:
    - from: "configurationApi.ts"
      to: "/api/v1/configuration/*"
      via: "apiClient from @/lib/api"
      pattern: "apiClient\\.(get|put|post)"
    - from: "useConfiguration.ts"
      to: "configurationApi.ts"
      via: "import and TanStack Query"
      pattern: "configurationApi\\."
---

<objective>
Configuration feature foundation with API layer, types, hooks, and Monaco editor component with preview toggle.

Purpose: Establishes the configuration feature structure following existing patterns (catalog, profile). Creates the Monaco-based markdown editor that will be used in the settings page, with toggle between edit and rendered preview mode.

Output:
- `features/configuration/` directory with api, hooks, components
- Monaco Editor component with dark theme and preview toggle
- TanStack Query hooks for all configuration operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-web-frontend-configuration/07-CONTEXT.md

# Existing patterns
@frontend/src/features/catalog/api/catalogApi.ts
@frontend/src/features/catalog/hooks/useCatalog.ts
@frontend/src/features/profile/types.ts
@frontend/src/lib/api.ts

# Backend API contract
@backend/src/atlas/entrypoints/api/routes/configuration.py

# For markdown preview (already in frontend from Phase 6)
@frontend/src/features/catalog/components/DocumentationViewer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Monaco Editor and create feature structure</name>
  <files>
    frontend/package.json
    frontend/src/features/configuration/types.ts
    frontend/src/features/configuration/index.ts
  </files>
  <action>
Install Monaco Editor React wrapper:
```bash
cd frontend && npm install @monaco-editor/react
```

Create `frontend/src/features/configuration/types.ts` with types matching backend:
```typescript
// Match backend/src/atlas/entrypoints/api/routes/configuration.py

export interface Configuration {
  content: string
  commit_sha: string
  updated_at: string  // ISO datetime from backend
}

export interface ConfigurationUpdate {
  content: string
  message?: string
}

export interface Version {
  commit_sha: string
  message: string
  author: string
  timestamp: string  // ISO datetime
}

export interface VersionHistory {
  versions: Version[]
  total: number
}
```

Create `frontend/src/features/configuration/index.ts` as barrel export:
```typescript
export * from './types'
export * from './hooks/useConfiguration'
export { ConfigurationEditor } from './components/ConfigurationEditor'
```
  </action>
  <verify>
`npm list @monaco-editor/react` shows installed
`ls frontend/src/features/configuration/` shows types.ts, index.ts
  </verify>
  <done>
Monaco installed, types match backend ConfigurationResponse/ConfigurationUpdateRequest/VersionResponse/VersionHistoryResponse
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API layer and TanStack Query hooks</name>
  <files>
    frontend/src/features/configuration/api/configurationApi.ts
    frontend/src/features/configuration/hooks/useConfiguration.ts
  </files>
  <action>
Create `frontend/src/features/configuration/api/configurationApi.ts`:
```typescript
import { apiClient } from '@/lib/api'
import type { Configuration, ConfigurationUpdate, VersionHistory } from '../types'

export const configurationApi = {
  // GET /api/v1/configuration/me
  getMyConfiguration: async (): Promise<Configuration> => {
    const { data } = await apiClient.get<Configuration>('/api/v1/configuration/me')
    return data
  },

  // PUT /api/v1/configuration/me
  updateConfiguration: async (update: ConfigurationUpdate): Promise<Configuration> => {
    const { data } = await apiClient.put<Configuration>('/api/v1/configuration/me', update)
    return data
  },

  // GET /api/v1/configuration/me/history
  getVersionHistory: async (limit = 50): Promise<VersionHistory> => {
    const { data } = await apiClient.get<VersionHistory>('/api/v1/configuration/me/history', {
      params: { limit },
    })
    return data
  },

  // POST /api/v1/configuration/me/rollback/{commit_sha}
  rollback: async (commitSha: string): Promise<Configuration> => {
    const { data } = await apiClient.post<Configuration>(
      `/api/v1/configuration/me/rollback/${commitSha}`
    )
    return data
  },

  // POST /api/v1/configuration/me/import (multipart form)
  importFile: async (file: File): Promise<Configuration> => {
    const formData = new FormData()
    formData.append('file', file)
    const { data } = await apiClient.post<Configuration>(
      '/api/v1/configuration/me/import',
      formData,
      {
        headers: { 'Content-Type': 'multipart/form-data' },
      }
    )
    return data
  },
}
```

Create `frontend/src/features/configuration/hooks/useConfiguration.ts`:
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { configurationApi } from '../api/configurationApi'
import type { ConfigurationUpdate } from '../types'

export const configurationKeys = {
  all: ['configuration'] as const,
  me: () => [...configurationKeys.all, 'me'] as const,
  history: (limit?: number) => [...configurationKeys.all, 'history', limit] as const,
}

export function useConfiguration() {
  return useQuery({
    queryKey: configurationKeys.me(),
    queryFn: configurationApi.getMyConfiguration,
  })
}

export function useUpdateConfiguration() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (update: ConfigurationUpdate) => configurationApi.updateConfiguration(update),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: configurationKeys.all })
      queryClient.invalidateQueries({ queryKey: ['profile', 'effectiveConfiguration'] })
      queryClient.invalidateQueries({ queryKey: ['profile', 'dashboard'] })
    },
  })
}

export function useVersionHistory(limit = 50) {
  return useQuery({
    queryKey: configurationKeys.history(limit),
    queryFn: () => configurationApi.getVersionHistory(limit),
  })
}

export function useRollback() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (commitSha: string) => configurationApi.rollback(commitSha),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: configurationKeys.all })
      queryClient.invalidateQueries({ queryKey: ['profile', 'effectiveConfiguration'] })
      queryClient.invalidateQueries({ queryKey: ['profile', 'dashboard'] })
    },
  })
}

export function useImportConfiguration() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (file: File) => configurationApi.importFile(file),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: configurationKeys.all })
      queryClient.invalidateQueries({ queryKey: ['profile', 'effectiveConfiguration'] })
      queryClient.invalidateQueries({ queryKey: ['profile', 'dashboard'] })
    },
  })
}
```
  </action>
  <verify>
TypeScript compilation: `cd frontend && npx tsc --noEmit` passes
Files exist at expected paths
  </verify>
  <done>
API layer calls all 5 backend endpoints
Hooks invalidate related caches (configuration, profile.effectiveConfiguration, profile.dashboard)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Monaco Editor component with preview toggle</name>
  <files>
    frontend/src/features/configuration/components/ConfigurationEditor.tsx
  </files>
  <action>
Create `frontend/src/features/configuration/components/ConfigurationEditor.tsx`:

```typescript
import { useCallback, useState } from 'react'
import Editor, { type OnChange, type OnMount } from '@monaco-editor/react'
import ReactMarkdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import { Eye, Code } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { cn } from '@/lib/utils'

interface ConfigurationEditorProps {
  value: string
  onChange: (value: string) => void
  readOnly?: boolean
}

export function ConfigurationEditor({ value, onChange, readOnly = false }: ConfigurationEditorProps) {
  const [mode, setMode] = useState<'edit' | 'preview'>('edit')

  const handleChange: OnChange = useCallback(
    (val) => {
      if (val !== undefined) {
        onChange(val)
      }
    },
    [onChange]
  )

  const handleMount: OnMount = useCallback((editor) => {
    // Focus editor on mount (only in edit mode)
    if (!readOnly) {
      editor.focus()
    }
  }, [readOnly])

  return (
    <div className="border border-border rounded-lg overflow-hidden">
      {/* Toolbar with mode toggle */}
      <div className="flex items-center justify-between px-3 py-2 border-b border-border bg-muted/30">
        <span className="text-sm text-muted-foreground">
          {readOnly ? 'Read-only preview' : 'claude.md'}
        </span>
        {!readOnly && (
          <div className="flex items-center gap-1">
            <Button
              variant={mode === 'edit' ? 'secondary' : 'ghost'}
              size="sm"
              onClick={() => setMode('edit')}
              className="gap-1.5 h-7 px-2"
            >
              <Code className="h-3.5 w-3.5" />
              Edit
            </Button>
            <Button
              variant={mode === 'preview' ? 'secondary' : 'ghost'}
              size="sm"
              onClick={() => setMode('preview')}
              className="gap-1.5 h-7 px-2"
            >
              <Eye className="h-3.5 w-3.5" />
              Preview
            </Button>
          </div>
        )}
      </div>

      {/* Content area */}
      <div className="h-[500px]">
        {mode === 'edit' || readOnly ? (
          <Editor
            height="100%"
            defaultLanguage="markdown"
            value={value}
            onChange={handleChange}
            onMount={handleMount}
            theme="vs-dark"
            options={{
              readOnly,
              minimap: { enabled: false },
              fontSize: 14,
              lineNumbers: 'on',
              wordWrap: 'on',
              scrollBeyondLastLine: false,
              automaticLayout: true,
              padding: { top: 16, bottom: 16 },
              renderLineHighlight: 'line',
              cursorBlinking: 'smooth',
              tabSize: 2,
            }}
            loading={
              <div className="h-full flex items-center justify-center text-muted-foreground">
                Loading editor...
              </div>
            }
          />
        ) : (
          <div className="h-full overflow-auto p-6 prose prose-invert max-w-none">
            <ReactMarkdown remarkPlugins={[remarkGfm]}>
              {value || '*No content*'}
            </ReactMarkdown>
          </div>
        )}
      </div>
    </div>
  )
}
```

Note: Using vs-dark theme which is Monaco's built-in dark theme. Preview uses react-markdown with remarkGfm (already in frontend from Phase 6 DocumentationViewer). The toggle buttons switch between Monaco editor view and rendered markdown preview.
  </action>
  <verify>
`cd frontend && npx tsc --noEmit` passes
Component has edit/preview toggle buttons
Component renders Monaco in edit mode, ReactMarkdown in preview mode
  </verify>
  <done>
Monaco editor with dark theme, markdown language, VS Code-like experience
Preview mode renders markdown using react-markdown (from Phase 6)
Toggle buttons: Edit (code icon) and Preview (eye icon)
Options: no minimap, word wrap, 14px font, line numbers, smooth cursor
  </done>
</task>

</tasks>

<verification>
All artifacts created:
- `features/configuration/types.ts` with 4 interfaces
- `features/configuration/api/configurationApi.ts` with 5 API methods
- `features/configuration/hooks/useConfiguration.ts` with 5 hooks
- `features/configuration/components/ConfigurationEditor.tsx` with Monaco and preview toggle

TypeScript compiles without errors:
```bash
cd frontend && npx tsc --noEmit
```

Preview toggle verification:
- Click "Preview" button - shows rendered markdown
- Click "Edit" button - shows Monaco editor
</verification>

<success_criteria>
1. Monaco Editor package installed
2. Types match backend API contract exactly
3. API layer calls all 5 configuration endpoints
4. TanStack Query hooks invalidate related caches on mutation
5. ConfigurationEditor component renders Monaco with dark theme
6. ConfigurationEditor has edit/preview toggle that switches between Monaco and rendered markdown
7. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-web-frontend-configuration/07-01-SUMMARY.md`
</output>
