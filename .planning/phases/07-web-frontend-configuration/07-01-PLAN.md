---
phase: 07-web-frontend-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/features/configuration/types.ts
  - frontend/src/features/configuration/api/configurationApi.ts
  - frontend/src/features/configuration/hooks/useConfiguration.ts
  - frontend/src/features/configuration/components/ConfigurationEditor.tsx
  - frontend/src/features/configuration/index.ts
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "Configuration API layer matches backend endpoints"
    - "Monaco editor renders with dark theme"
    - "Types match backend response shapes"
  artifacts:
    - path: "frontend/src/features/configuration/types.ts"
      provides: "TypeScript types matching backend"
      contains: "Configuration, ConfigurationUpdate, Version, VersionHistory"
    - path: "frontend/src/features/configuration/api/configurationApi.ts"
      provides: "API calls to backend"
      exports: ["configurationApi"]
    - path: "frontend/src/features/configuration/hooks/useConfiguration.ts"
      provides: "TanStack Query hooks"
      exports: ["useConfiguration", "useUpdateConfiguration", "useVersionHistory", "useRollback", "useImportConfiguration"]
    - path: "frontend/src/features/configuration/components/ConfigurationEditor.tsx"
      provides: "Monaco markdown editor"
      exports: ["ConfigurationEditor"]
  key_links:
    - from: "configurationApi.ts"
      to: "/api/v1/configuration/*"
      via: "apiClient from @/lib/api"
      pattern: "apiClient\\.(get|put|post)"
    - from: "useConfiguration.ts"
      to: "configurationApi.ts"
      via: "import and TanStack Query"
      pattern: "configurationApi\\."
---

<objective>
Configuration feature foundation with API layer, types, hooks, and Monaco editor component.

Purpose: Establishes the configuration feature structure following existing patterns (catalog, profile). Creates the Monaco-based markdown editor that will be used in the settings page.

Output:
- `features/configuration/` directory with api, hooks, components
- Monaco Editor component with dark theme
- TanStack Query hooks for all configuration operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-web-frontend-configuration/07-CONTEXT.md

# Existing patterns
@frontend/src/features/catalog/api/catalogApi.ts
@frontend/src/features/catalog/hooks/useCatalog.ts
@frontend/src/features/profile/types.ts
@frontend/src/lib/api.ts

# Backend API contract
@backend/src/atlas/entrypoints/api/routes/configuration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Monaco Editor and create feature structure</name>
  <files>
    frontend/package.json
    frontend/src/features/configuration/types.ts
    frontend/src/features/configuration/index.ts
  </files>
  <action>
Install Monaco Editor React wrapper:
```bash
cd frontend && npm install @monaco-editor/react
```

Create `frontend/src/features/configuration/types.ts` with types matching backend:
```typescript
// Match backend/src/atlas/entrypoints/api/routes/configuration.py

export interface Configuration {
  content: string
  commit_sha: string
  updated_at: string  // ISO datetime from backend
}

export interface ConfigurationUpdate {
  content: string
  message?: string
}

export interface Version {
  commit_sha: string
  message: string
  author: string
  timestamp: string  // ISO datetime
}

export interface VersionHistory {
  versions: Version[]
  total: number
}
```

Create `frontend/src/features/configuration/index.ts` as barrel export:
```typescript
export * from './types'
export * from './hooks/useConfiguration'
export { ConfigurationEditor } from './components/ConfigurationEditor'
```
  </action>
  <verify>
`npm list @monaco-editor/react` shows installed
`ls frontend/src/features/configuration/` shows types.ts, index.ts
  </verify>
  <done>
Monaco installed, types match backend ConfigurationResponse/ConfigurationUpdateRequest/VersionResponse/VersionHistoryResponse
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API layer and TanStack Query hooks</name>
  <files>
    frontend/src/features/configuration/api/configurationApi.ts
    frontend/src/features/configuration/hooks/useConfiguration.ts
  </files>
  <action>
Create `frontend/src/features/configuration/api/configurationApi.ts`:
```typescript
import { apiClient } from '@/lib/api'
import type { Configuration, ConfigurationUpdate, VersionHistory } from '../types'

export const configurationApi = {
  // GET /api/v1/configuration/me
  getMyConfiguration: async (): Promise<Configuration> => {
    const { data } = await apiClient.get<Configuration>('/api/v1/configuration/me')
    return data
  },

  // PUT /api/v1/configuration/me
  updateConfiguration: async (update: ConfigurationUpdate): Promise<Configuration> => {
    const { data } = await apiClient.put<Configuration>('/api/v1/configuration/me', update)
    return data
  },

  // GET /api/v1/configuration/me/history
  getVersionHistory: async (limit = 50): Promise<VersionHistory> => {
    const { data } = await apiClient.get<VersionHistory>('/api/v1/configuration/me/history', {
      params: { limit },
    })
    return data
  },

  // POST /api/v1/configuration/me/rollback/{commit_sha}
  rollback: async (commitSha: string): Promise<Configuration> => {
    const { data } = await apiClient.post<Configuration>(
      `/api/v1/configuration/me/rollback/${commitSha}`
    )
    return data
  },

  // POST /api/v1/configuration/me/import (multipart form)
  importFile: async (file: File): Promise<Configuration> => {
    const formData = new FormData()
    formData.append('file', file)
    const { data } = await apiClient.post<Configuration>(
      '/api/v1/configuration/me/import',
      formData,
      {
        headers: { 'Content-Type': 'multipart/form-data' },
      }
    )
    return data
  },
}
```

Create `frontend/src/features/configuration/hooks/useConfiguration.ts`:
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { configurationApi } from '../api/configurationApi'
import type { ConfigurationUpdate } from '../types'

export const configurationKeys = {
  all: ['configuration'] as const,
  me: () => [...configurationKeys.all, 'me'] as const,
  history: (limit?: number) => [...configurationKeys.all, 'history', limit] as const,
}

export function useConfiguration() {
  return useQuery({
    queryKey: configurationKeys.me(),
    queryFn: configurationApi.getMyConfiguration,
  })
}

export function useUpdateConfiguration() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (update: ConfigurationUpdate) => configurationApi.updateConfiguration(update),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: configurationKeys.all })
      queryClient.invalidateQueries({ queryKey: ['profile', 'effectiveConfiguration'] })
      queryClient.invalidateQueries({ queryKey: ['profile', 'dashboard'] })
    },
  })
}

export function useVersionHistory(limit = 50) {
  return useQuery({
    queryKey: configurationKeys.history(limit),
    queryFn: () => configurationApi.getVersionHistory(limit),
  })
}

export function useRollback() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (commitSha: string) => configurationApi.rollback(commitSha),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: configurationKeys.all })
      queryClient.invalidateQueries({ queryKey: ['profile', 'effectiveConfiguration'] })
      queryClient.invalidateQueries({ queryKey: ['profile', 'dashboard'] })
    },
  })
}

export function useImportConfiguration() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (file: File) => configurationApi.importFile(file),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: configurationKeys.all })
      queryClient.invalidateQueries({ queryKey: ['profile', 'effectiveConfiguration'] })
      queryClient.invalidateQueries({ queryKey: ['profile', 'dashboard'] })
    },
  })
}
```
  </action>
  <verify>
TypeScript compilation: `cd frontend && npx tsc --noEmit` passes
Files exist at expected paths
  </verify>
  <done>
API layer calls all 5 backend endpoints
Hooks invalidate related caches (configuration, profile.effectiveConfiguration, profile.dashboard)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Monaco Editor component</name>
  <files>
    frontend/src/features/configuration/components/ConfigurationEditor.tsx
  </files>
  <action>
Create `frontend/src/features/configuration/components/ConfigurationEditor.tsx`:

```typescript
import { useCallback } from 'react'
import Editor, { type OnChange, type OnMount } from '@monaco-editor/react'

interface ConfigurationEditorProps {
  value: string
  onChange: (value: string) => void
  readOnly?: boolean
}

export function ConfigurationEditor({ value, onChange, readOnly = false }: ConfigurationEditorProps) {
  const handleChange: OnChange = useCallback(
    (val) => {
      if (val !== undefined) {
        onChange(val)
      }
    },
    [onChange]
  )

  const handleMount: OnMount = useCallback((editor) => {
    // Focus editor on mount
    editor.focus()
  }, [])

  return (
    <div className="h-[500px] border border-border rounded-lg overflow-hidden">
      <Editor
        height="100%"
        defaultLanguage="markdown"
        value={value}
        onChange={handleChange}
        onMount={handleMount}
        theme="vs-dark"
        options={{
          readOnly,
          minimap: { enabled: false },
          fontSize: 14,
          lineNumbers: 'on',
          wordWrap: 'on',
          scrollBeyondLastLine: false,
          automaticLayout: true,
          padding: { top: 16, bottom: 16 },
          renderLineHighlight: 'line',
          cursorBlinking: 'smooth',
          tabSize: 2,
        }}
        loading={
          <div className="h-full flex items-center justify-center text-muted-foreground">
            Loading editor...
          </div>
        }
      />
    </div>
  )
}
```

Note: Using vs-dark theme which is Monaco's built-in dark theme. This matches well with the GitHub-style dark aesthetic of the app.
  </action>
  <verify>
`cd frontend && npx tsc --noEmit` passes
Component has correct props interface
  </verify>
  <done>
Monaco editor with dark theme, markdown language, VS Code-like experience
Options: no minimap, word wrap, 14px font, line numbers, smooth cursor
  </done>
</task>

</tasks>

<verification>
All artifacts created:
- `features/configuration/types.ts` with 4 interfaces
- `features/configuration/api/configurationApi.ts` with 5 API methods
- `features/configuration/hooks/useConfiguration.ts` with 5 hooks
- `features/configuration/components/ConfigurationEditor.tsx` with Monaco

TypeScript compiles without errors:
```bash
cd frontend && npx tsc --noEmit
```
</verification>

<success_criteria>
1. Monaco Editor package installed
2. Types match backend API contract exactly
3. API layer calls all 5 configuration endpoints
4. TanStack Query hooks invalidate related caches on mutation
5. ConfigurationEditor component renders Monaco with dark theme
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-web-frontend-configuration/07-01-SUMMARY.md`
</output>
