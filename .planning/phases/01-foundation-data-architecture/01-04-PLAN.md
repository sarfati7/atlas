---
phase: 01-foundation-data-architecture
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - backend/src/atlas/adapters/github/__init__.py
  - backend/src/atlas/adapters/github/content_repository.py
  - backend/src/atlas/adapters/in_memory/content_repository.py
  - backend/src/atlas/adapters/authorization/__init__.py
  - backend/src/atlas/adapters/authorization/permissive.py
  - backend/src/atlas/entrypoints/__init__.py
  - backend/src/atlas/entrypoints/dependencies.py
autonomous: true

must_haves:
  truths:
    - "GitHub content repository can fetch and save files via GitHub API"
    - "In-memory content repository provides identical interface for testing"
    - "Permissive authorization service returns True for all permission checks"
    - "Dependency injection wiring connects implementations to interfaces"
  artifacts:
    - path: "backend/src/atlas/adapters/github/content_repository.py"
      provides: "GitHub API integration for content files"
      contains: "class GitHubContentRepository"
    - path: "backend/src/atlas/adapters/in_memory/content_repository.py"
      provides: "In-memory content storage for testing"
      contains: "class InMemoryContentRepository"
    - path: "backend/src/atlas/adapters/authorization/permissive.py"
      provides: "Permissive (allow-all) authorization implementation"
      contains: "class PermissiveAuthorizationService"
    - path: "backend/src/atlas/entrypoints/dependencies.py"
      provides: "FastAPI dependency injection setup"
      contains: "get_user_repository"
  key_links:
    - from: "backend/src/atlas/adapters/github/content_repository.py"
      to: "backend/src/atlas/domain/interfaces/content_repository.py"
      via: "inherits from AbstractContentRepository"
      pattern: "class GitHubContentRepository\\(AbstractContentRepository\\)"
    - from: "backend/src/atlas/adapters/authorization/permissive.py"
      to: "backend/src/atlas/domain/interfaces/authorization.py"
      via: "inherits from AbstractAuthorizationService"
      pattern: "class PermissiveAuthorizationService\\(AbstractAuthorizationService\\)"
    - from: "backend/src/atlas/entrypoints/dependencies.py"
      to: "backend/src/atlas/adapters/postgresql/repositories/"
      via: "factory functions return concrete implementations"
      pattern: "return Postgres.*Repository"
---

<objective>
Implement GitHub content repository, authorization abstraction, and dependency injection wiring for the complete foundation layer.

Purpose: Complete Phase 1 by adding git-backed content storage (per critical architecture decision: git stores content, DB stores metadata), a permissive authorization layer that can evolve into RBAC, and the dependency injection setup that wires all implementations together.

Output: Working GitHub integration for content files, permissive authorization (allows everything for v1), and FastAPI dependency functions that provide all repositories and services.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-data-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-data-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-data-architecture/01-01-SUMMARY.md
@.planning/phases/01-foundation-data-architecture/01-02-SUMMARY.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GitHub content repository</name>
  <files>
    backend/src/atlas/adapters/github/__init__.py
    backend/src/atlas/adapters/github/content_repository.py
    backend/src/atlas/adapters/in_memory/content_repository.py
  </files>
  <action>
Create GitHub content repository per RESEARCH.md Pattern 5.

1. **GitHubContentRepository** (`adapters/github/content_repository.py`):
   - Inherits from `AbstractContentRepository`
   - Constructor takes `token: str` and `repo_name: str` (e.g., "owner/repo")
   - Initialize: `self._github = Github(token)` and `self._repo = self._github.get_repo(repo_name)`

   Implement methods:

   **get_content(path: str) -> Optional[str]:**
   ```python
   try:
       content = self._repo.get_contents(path)
       return content.decoded_content.decode("utf-8")
   except Exception:
       return None
   ```

   **save_content(path: str, content: str, message: str) -> str:**
   - Try to get existing file first
   - If exists: `self._repo.update_file(path, message, content, existing.sha)`
   - If not exists: `self._repo.create_file(path, message, content)`
   - Return commit SHA from result

   **delete_content(path: str, message: str) -> str:**
   - Get existing file SHA
   - Call `self._repo.delete_file(path, message, sha)`
   - Return commit SHA

   **list_contents(directory: str) -> list[str]:**
   - `contents = self._repo.get_contents(directory)`
   - Return `[c.path for c in contents]`
   - Handle case where directory doesn't exist (return empty list)

   Note: PyGithub is synchronous. Wrap calls appropriately for async interface:
   - Use `asyncio.to_thread()` to run in thread pool, or
   - Keep methods simple (GitHub API is I/O bound, async wrapper is fine)

2. **InMemoryContentRepository** (`adapters/in_memory/content_repository.py`):
   - Internal storage: `self._contents: dict[str, str] = {}` (path -> content)
   - `get_content`: Dict lookup
   - `save_content`: Store in dict, return fake commit SHA (uuid4().hex[:7])
   - `delete_content`: Pop from dict
   - `list_contents`: Filter keys by directory prefix
   - Add `clear()` method for tests

3. Create `__init__.py` files exporting classes.
  </action>
  <verify>
Run `cd backend && python -c "
from atlas.adapters.github.content_repository import GitHubContentRepository
from atlas.adapters.in_memory.content_repository import InMemoryContentRepository
from atlas.domain.interfaces import AbstractContentRepository
print(f'GitHub inherits Abstract: {issubclass(GitHubContentRepository, AbstractContentRepository)}')
print(f'InMemory inherits Abstract: {issubclass(InMemoryContentRepository, AbstractContentRepository)}')
print('Content repositories OK')
"`.
  </verify>
  <done>
GitHub and in-memory content repositories implement AbstractContentRepository interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement permissive authorization service</name>
  <files>
    backend/src/atlas/adapters/authorization/__init__.py
    backend/src/atlas/adapters/authorization/permissive.py
  </files>
  <action>
Create the permissive authorization implementation per RESEARCH.md Pattern 4.

1. **PermissiveAuthorizationService** (`adapters/authorization/permissive.py`):
   - Inherits from `AbstractAuthorizationService`
   - All methods return `True` (allow everything for v1)
   - Add docstrings noting this is a placeholder for future RBAC

   ```python
   class PermissiveAuthorizationService(AbstractAuthorizationService):
       """
       Phase 1 implementation: allows all operations.

       This provides the authorization abstraction from day one,
       making it easy to implement actual RBAC in a later phase
       without changing the calling code.
       """

       async def can_view_skill(self, user: User, skill: CatalogItem) -> bool:
           # TODO: Implement actual RBAC in Phase 9
           return True

       async def can_edit_skill(self, user: User, skill: CatalogItem) -> bool:
           return True

       async def can_delete_skill(self, user: User, skill: CatalogItem) -> bool:
           return True

       # Same for MCP and Tool variants...
   ```

2. Also create generic methods that work for any catalog item type:
   - `async def can_view(self, user: User, item: CatalogItem) -> bool`
   - `async def can_edit(self, user: User, item: CatalogItem) -> bool`
   - `async def can_delete(self, user: User, item: CatalogItem) -> bool`

3. Create `__init__.py` exporting `PermissiveAuthorizationService`.
  </action>
  <verify>
Run `cd backend && python -c "
import asyncio
from atlas.adapters.authorization import PermissiveAuthorizationService
from atlas.domain.interfaces import AbstractAuthorizationService
from atlas.domain.entities import User, CatalogItem, CatalogItemType
from uuid import uuid4
from datetime import datetime

async def test():
    auth = PermissiveAuthorizationService()
    user = User(id=uuid4(), email='test@example.com', username='test', created_at=datetime.utcnow(), updated_at=datetime.utcnow(), team_ids=[])
    skill = CatalogItem(id=uuid4(), type=CatalogItemType.SKILL, name='test', description='', git_path='skills/test.md', author_id=uuid4(), team_id=None, tags=[], usage_count=0, created_at=datetime.utcnow(), updated_at=datetime.utcnow())

    assert await auth.can_view_skill(user, skill) == True
    assert await auth.can_edit_skill(user, skill) == True
    print('Permissive authorization returns True for all checks')

asyncio.run(test())
"`.
  </verify>
  <done>
Permissive authorization service allows all operations, providing the abstraction layer for future RBAC.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create FastAPI dependency injection setup</name>
  <files>
    backend/src/atlas/entrypoints/__init__.py
    backend/src/atlas/entrypoints/dependencies.py
  </files>
  <action>
Create the dependency injection wiring per RESEARCH.md FastAPI DI pattern.

1. **dependencies.py** (`entrypoints/dependencies.py`):

   Import all interfaces and implementations:
   ```python
   from typing import Annotated, AsyncGenerator
   from fastapi import Depends

   from atlas.config import settings
   from atlas.adapters.postgresql.session import get_session, AsyncSession
   from atlas.adapters.postgresql.repositories import (
       PostgresUserRepository,
       PostgresTeamRepository,
       PostgresCatalogRepository,
   )
   from atlas.adapters.github.content_repository import GitHubContentRepository
   from atlas.adapters.authorization.permissive import PermissiveAuthorizationService
   from atlas.domain.interfaces import (
       AbstractUserRepository,
       AbstractTeamRepository,
       AbstractCatalogRepository,
       AbstractContentRepository,
       AbstractAuthorizationService,
   )
   ```

2. Create dependency provider functions:

   **Repository dependencies:**
   ```python
   async def get_user_repository(
       session: Annotated[AsyncSession, Depends(get_session)]
   ) -> AbstractUserRepository:
       return PostgresUserRepository(session)

   async def get_team_repository(
       session: Annotated[AsyncSession, Depends(get_session)]
   ) -> AbstractTeamRepository:
       return PostgresTeamRepository(session)

   async def get_catalog_repository(
       session: Annotated[AsyncSession, Depends(get_session)]
   ) -> AbstractCatalogRepository:
       return PostgresCatalogRepository(session)
   ```

   **Content repository (conditional on config):**
   ```python
   async def get_content_repository() -> AbstractContentRepository:
       if settings.github_token and settings.github_repo:
           return GitHubContentRepository(settings.github_token, settings.github_repo)
       # Fallback to in-memory for development without GitHub config
       from atlas.adapters.in_memory.content_repository import InMemoryContentRepository
       return InMemoryContentRepository()
   ```

   **Authorization service:**
   ```python
   async def get_authorization_service() -> AbstractAuthorizationService:
       return PermissiveAuthorizationService()
   ```

3. Create type aliases for cleaner route signatures:
   ```python
   UserRepo = Annotated[AbstractUserRepository, Depends(get_user_repository)]
   TeamRepo = Annotated[AbstractTeamRepository, Depends(get_team_repository)]
   CatalogRepo = Annotated[AbstractCatalogRepository, Depends(get_catalog_repository)]
   ContentRepo = Annotated[AbstractContentRepository, Depends(get_content_repository)]
   AuthService = Annotated[AbstractAuthorizationService, Depends(get_authorization_service)]
   ```

4. Update `entrypoints/__init__.py` to export dependency functions and type aliases.
  </action>
  <verify>
Run `cd backend && python -c "
from atlas.entrypoints.dependencies import (
    get_user_repository,
    get_team_repository,
    get_catalog_repository,
    get_content_repository,
    get_authorization_service,
    UserRepo, TeamRepo, CatalogRepo, ContentRepo, AuthService
)
print('All dependency providers importable')
print('Type aliases defined: UserRepo, TeamRepo, CatalogRepo, ContentRepo, AuthService')
"`.
  </verify>
  <done>
FastAPI dependency injection setup complete, all implementations wired to abstract interfaces.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full import chain verification:
   ```bash
   cd backend && python -c "
   # Domain
   from atlas.domain.entities import User, Team, CatalogItem, CatalogItemType
   from atlas.domain.interfaces import (
       AbstractUserRepository,
       AbstractTeamRepository,
       AbstractCatalogRepository,
       AbstractContentRepository,
       AbstractAuthorizationService
   )

   # Adapters - PostgreSQL
   from atlas.adapters.postgresql.models import UserModel, TeamModel, CatalogItemModel
   from atlas.adapters.postgresql.repositories import PostgresUserRepository, PostgresTeamRepository, PostgresCatalogRepository
   from atlas.adapters.postgresql.session import get_session

   # Adapters - GitHub
   from atlas.adapters.github import GitHubContentRepository

   # Adapters - In-memory
   from atlas.adapters.in_memory.repositories import InMemoryUserRepository, InMemoryTeamRepository, InMemoryCatalogRepository
   from atlas.adapters.in_memory.content_repository import InMemoryContentRepository

   # Adapters - Authorization
   from atlas.adapters.authorization import PermissiveAuthorizationService

   # Entrypoints
   from atlas.entrypoints.dependencies import get_user_repository, get_authorization_service

   print('Complete import chain successful - Phase 1 foundation complete')
   "
   ```

2. Interface implementation verification:
   ```bash
   cd backend && python -c "
   from atlas.domain.interfaces import AbstractContentRepository, AbstractAuthorizationService
   from atlas.adapters.github import GitHubContentRepository
   from atlas.adapters.in_memory.content_repository import InMemoryContentRepository
   from atlas.adapters.authorization import PermissiveAuthorizationService

   assert issubclass(GitHubContentRepository, AbstractContentRepository)
   assert issubclass(InMemoryContentRepository, AbstractContentRepository)
   assert issubclass(PermissiveAuthorizationService, AbstractAuthorizationService)
   print('All implementations correctly inherit from abstract interfaces')
   "
   ```

3. Quick in-memory content repository test:
   ```bash
   cd backend && python -c "
   import asyncio
   from atlas.adapters.in_memory.content_repository import InMemoryContentRepository

   async def test():
       repo = InMemoryContentRepository()
       sha = await repo.save_content('skills/test.md', '# Test Skill', 'Add test skill')
       content = await repo.get_content('skills/test.md')
       assert content == '# Test Skill'
       files = await repo.list_contents('skills/')
       assert 'skills/test.md' in files
       print(f'Content repo test passed (commit: {sha})')

   asyncio.run(test())
   "
   ```
</verification>

<success_criteria>
- GitHub content repository implements file operations via PyGithub
- In-memory content repository provides testing alternative
- Permissive authorization service returns True for all permission checks
- Authorization abstraction is in place for future RBAC evolution
- Dependency injection wiring connects all implementations to interfaces
- Type aliases simplify route signatures
- Full import chain works without circular dependencies
- Phase 1 success criteria from ROADMAP.md are met:
  1. PostgreSQL database models exist (from 01-02)
  2. Git repository integration exists (this plan)
  3. Authorization abstraction exists (this plan)
  4. Schema versioning with Alembic (from 01-02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-architecture/01-04-SUMMARY.md`
</output>
