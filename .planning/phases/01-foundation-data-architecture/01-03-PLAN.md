---
phase: 01-foundation-data-architecture
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - backend/src/atlas/adapters/postgresql/repositories/__init__.py
  - backend/src/atlas/adapters/postgresql/repositories/user_repository.py
  - backend/src/atlas/adapters/postgresql/repositories/team_repository.py
  - backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py
  - backend/src/atlas/adapters/in_memory/__init__.py
  - backend/src/atlas/adapters/in_memory/repositories/__init__.py
  - backend/src/atlas/adapters/in_memory/repositories/user_repository.py
  - backend/src/atlas/adapters/in_memory/repositories/team_repository.py
  - backend/src/atlas/adapters/in_memory/repositories/catalog_repository.py
autonomous: true

must_haves:
  truths:
    - "PostgreSQL repository implementations fulfill all abstract repository methods"
    - "In-memory repository implementations provide identical interface for testing"
    - "Both implementations can be injected interchangeably via the abstract interface"
    - "Repository pattern isolates database access from business logic"
  artifacts:
    - path: "backend/src/atlas/adapters/postgresql/repositories/user_repository.py"
      provides: "PostgreSQL user repository implementation"
      contains: "class PostgresUserRepository"
    - path: "backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py"
      provides: "PostgreSQL catalog repository implementation"
      contains: "class PostgresCatalogRepository"
    - path: "backend/src/atlas/adapters/in_memory/repositories/user_repository.py"
      provides: "In-memory user repository for testing"
      contains: "class InMemoryUserRepository"
    - path: "backend/src/atlas/adapters/in_memory/repositories/catalog_repository.py"
      provides: "In-memory catalog repository for testing"
      contains: "class InMemoryCatalogRepository"
  key_links:
    - from: "backend/src/atlas/adapters/postgresql/repositories/user_repository.py"
      to: "backend/src/atlas/domain/interfaces/user_repository.py"
      via: "inherits from AbstractUserRepository"
      pattern: "class PostgresUserRepository\\(AbstractUserRepository\\)"
    - from: "backend/src/atlas/adapters/in_memory/repositories/user_repository.py"
      to: "backend/src/atlas/domain/interfaces/user_repository.py"
      via: "inherits from AbstractUserRepository"
      pattern: "class InMemoryUserRepository\\(AbstractUserRepository\\)"
---

<objective>
Implement repository pattern with both PostgreSQL and in-memory implementations for all data access operations.

Purpose: Create the concrete data access layer following CLAUDE.md's requirement that every interface has two implementations - real (PostgreSQL) for production and in-memory for testing. This enables full application testing without database dependencies.

Output: Complete repository implementations for User, Team, and CatalogItem in both PostgreSQL (using async SQLModel) and in-memory (using dictionaries) variants.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-data-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-data-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-data-architecture/01-01-SUMMARY.md
@.planning/phases/01-foundation-data-architecture/01-02-SUMMARY.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PostgreSQL repositories</name>
  <files>
    backend/src/atlas/adapters/postgresql/repositories/__init__.py
    backend/src/atlas/adapters/postgresql/repositories/user_repository.py
    backend/src/atlas/adapters/postgresql/repositories/team_repository.py
    backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py
  </files>
  <action>
Create PostgreSQL repository implementations per RESEARCH.md Pattern 2.

1. **PostgresUserRepository** (`repositories/user_repository.py`):
   - Inherits from `AbstractUserRepository`
   - Constructor takes `session: AsyncSession`
   - Implement all methods using async SQLModel queries:
     - `get_by_id`: `select(UserModel).where(UserModel.id == user_id)`
     - `get_by_email`: `select(UserModel).where(UserModel.email == email)`
     - `save`: Use `session.add()` + `session.commit()` + `session.refresh()`
     - `delete`: Fetch then `session.delete()` + `session.commit()`
     - `list_all`: `select(UserModel)` with `scalars().all()`
   - Convert between UserModel (SQLModel) and User (domain entity) in each method
   - Use `result.scalar_one_or_none()` for single results

2. **PostgresTeamRepository** (`repositories/team_repository.py`):
   - Same pattern as UserRepository
   - `get_user_teams`: Join query through UserTeamLink table
     ```python
     statement = (
         select(TeamModel)
         .join(UserTeamLink)
         .where(UserTeamLink.user_id == user_id)
     )
     ```

3. **PostgresCatalogRepository** (`repositories/catalog_repository.py`):
   - `list_by_type`: Filter by CatalogItemType enum
   - `search`: Use ILIKE for case-insensitive search on name and description
     ```python
     statement = select(CatalogItemModel).where(
         or_(
             CatalogItemModel.name.ilike(f"%{query}%"),
             CatalogItemModel.description.ilike(f"%{query}%")
         )
     )
     ```
   - `get_by_git_path`: Exact match on git_path field

4. Create `__init__.py` exporting all repository classes.

IMPORTANT: Each repository method should:
- Accept domain entities as input
- Return domain entities as output
- Handle the Model <-> Entity conversion internally
  </action>
  <verify>
Run `cd backend && python -c "
from atlas.adapters.postgresql.repositories import PostgresUserRepository, PostgresTeamRepository, PostgresCatalogRepository
from atlas.domain.interfaces import AbstractUserRepository
print(f'PostgresUserRepository inherits AbstractUserRepository: {issubclass(PostgresUserRepository, AbstractUserRepository)}')
print('PostgreSQL repositories OK')
"`.
  </verify>
  <done>
All PostgreSQL repositories implement their abstract interfaces with proper async queries and entity conversion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement in-memory repositories</name>
  <files>
    backend/src/atlas/adapters/in_memory/__init__.py
    backend/src/atlas/adapters/in_memory/repositories/__init__.py
    backend/src/atlas/adapters/in_memory/repositories/user_repository.py
    backend/src/atlas/adapters/in_memory/repositories/team_repository.py
    backend/src/atlas/adapters/in_memory/repositories/catalog_repository.py
  </files>
  <action>
Create in-memory repository implementations for testing per CLAUDE.md and RESEARCH.md Pattern 2.

1. **InMemoryUserRepository** (`in_memory/repositories/user_repository.py`):
   - Inherits from `AbstractUserRepository`
   - Internal storage: `self._users: dict[UUID, User] = {}`
   - All methods are async (even though they don't need to be) to match interface
   - `get_by_id`: Simple dict lookup
   - `get_by_email`: Linear search through values
   - `save`: Store in dict, generate UUID if not present
   - `delete`: Pop from dict
   - `list_all`: Return list of all values

2. **InMemoryTeamRepository** (`in_memory/repositories/team_repository.py`):
   - Internal storage: `self._teams: dict[UUID, Team] = {}`
   - Also track memberships: `self._memberships: dict[UUID, set[UUID]] = {}` (user_id -> team_ids)
   - `get_user_teams`: Look up user's team_ids, return those teams

3. **InMemoryCatalogRepository** (`in_memory/repositories/catalog_repository.py`):
   - Internal storage: `self._items: dict[UUID, CatalogItem] = {}`
   - `list_by_type`: Filter by item.type
   - `search`: Case-insensitive substring match on name and description
   - `get_by_git_path`: Linear search by git_path

4. Add helper method to all in-memory repos:
   - `def clear(self) -> None`: Reset storage (useful in tests)

5. Create `__init__.py` files exporting all classes.

IMPORTANT: In-memory repos work with domain entities directly (no model conversion needed).
  </action>
  <verify>
Run `cd backend && python -c "
from atlas.adapters.in_memory.repositories import InMemoryUserRepository, InMemoryTeamRepository, InMemoryCatalogRepository
from atlas.domain.interfaces import AbstractUserRepository
print(f'InMemoryUserRepository inherits AbstractUserRepository: {issubclass(InMemoryUserRepository, AbstractUserRepository)}')
print('In-memory repositories OK')
"`.
  </verify>
  <done>
All in-memory repositories implement their abstract interfaces with dict-based storage for testing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add entity-model conversion utilities</name>
  <files>
    backend/src/atlas/adapters/postgresql/converters.py
  </files>
  <action>
Create converter functions to transform between domain entities and SQLModel models.

1. Create `adapters/postgresql/converters.py`:

   **User conversions:**
   ```python
   def user_model_to_entity(model: UserModel) -> User:
       return User(
           id=model.id,
           email=model.email,
           username=model.username,
           created_at=model.created_at,
           updated_at=model.updated_at,
           team_ids=[team.id for team in model.teams] if model.teams else []
       )

   def user_entity_to_model(entity: User) -> UserModel:
       return UserModel(
           id=entity.id,
           email=entity.email,
           username=entity.username,
           password_hash="",  # Set separately during auth
           created_at=entity.created_at,
           updated_at=entity.updated_at,
       )
   ```

   **Team conversions:**
   - Similar pattern, handle member_ids list

   **CatalogItem conversions:**
   - Handle tags JSON string <-> list[str] conversion
   - Map CatalogItemType enum correctly

2. Update PostgreSQL repositories to use these converters instead of inline conversion.

3. Export converters from `adapters/postgresql/__init__.py`.

This keeps conversion logic centralized and testable.
  </action>
  <verify>
Run `cd backend && python -c "
from atlas.adapters.postgresql.converters import user_model_to_entity, user_entity_to_model
from atlas.adapters.postgresql.models import UserModel
from atlas.domain.entities import User
from uuid import uuid4
from datetime import datetime

# Test round-trip
model = UserModel(id=uuid4(), email='test@example.com', username='testuser', password_hash='hash', created_at=datetime.utcnow(), updated_at=datetime.utcnow())
entity = user_model_to_entity(model)
print(f'Entity email: {entity.email}')
print('Converters OK')
"`.
  </verify>
  <done>
Converter utilities centralize entity/model transformation, repositories use converters consistently.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Interface compliance check (both implementations inherit correctly):
   ```bash
   cd backend && python -c "
   from atlas.domain.interfaces import AbstractUserRepository, AbstractTeamRepository, AbstractCatalogRepository
   from atlas.adapters.postgresql.repositories import PostgresUserRepository, PostgresTeamRepository, PostgresCatalogRepository
   from atlas.adapters.in_memory.repositories import InMemoryUserRepository, InMemoryTeamRepository, InMemoryCatalogRepository

   # Verify inheritance
   assert issubclass(PostgresUserRepository, AbstractUserRepository)
   assert issubclass(InMemoryUserRepository, AbstractUserRepository)
   assert issubclass(PostgresTeamRepository, AbstractTeamRepository)
   assert issubclass(InMemoryTeamRepository, AbstractTeamRepository)
   assert issubclass(PostgresCatalogRepository, AbstractCatalogRepository)
   assert issubclass(InMemoryCatalogRepository, AbstractCatalogRepository)

   print('All repositories correctly inherit from abstract interfaces')
   "
   ```

2. Quick functional test with in-memory repo:
   ```bash
   cd backend && python -c "
   import asyncio
   from atlas.adapters.in_memory.repositories import InMemoryUserRepository
   from atlas.domain.entities import User
   from uuid import uuid4
   from datetime import datetime

   async def test():
       repo = InMemoryUserRepository()
       user = User(
           id=uuid4(),
           email='test@example.com',
           username='testuser',
           created_at=datetime.utcnow(),
           updated_at=datetime.utcnow(),
           team_ids=[]
       )
       saved = await repo.save(user)
       fetched = await repo.get_by_email('test@example.com')
       assert fetched is not None
       assert fetched.username == 'testuser'
       print('In-memory repository functional test passed')

   asyncio.run(test())
   "
   ```

3. Verify no circular imports:
   ```bash
   cd backend && python -c "
   from atlas.adapters.postgresql.repositories import *
   from atlas.adapters.in_memory.repositories import *
   print('No circular import issues')
   "
   ```
</verification>

<success_criteria>
- PostgreSQL repositories implement all abstract interface methods
- In-memory repositories implement identical interfaces
- Both implementations can be swapped via dependency injection
- Converters handle entity/model transformation cleanly
- Repository pattern successfully isolates database details from domain
- All repositories are importable without circular dependency issues
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-architecture/01-03-SUMMARY.md`
</output>
