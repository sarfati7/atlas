---
phase: 01-foundation-data-architecture
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/atlas/adapters/__init__.py
  - backend/src/atlas/adapters/postgresql/__init__.py
  - backend/src/atlas/adapters/postgresql/models.py
  - backend/src/atlas/adapters/postgresql/session.py
  - backend/alembic.ini
  - backend/migrations/env.py
  - backend/migrations/script.py.mako
  - backend/migrations/versions/
  - backend/src/atlas/config.py
autonomous: true

must_haves:
  truths:
    - "SQLModel table models exist for User, Team, CatalogItem, and UserTeamLink"
    - "Alembic migrations can be generated and run against PostgreSQL"
    - "Async session factory creates working database connections"
    - "Database schema matches domain entity structure"
  artifacts:
    - path: "backend/src/atlas/adapters/postgresql/models.py"
      provides: "SQLModel ORM table definitions"
      contains: "class UserModel"
    - path: "backend/src/atlas/adapters/postgresql/session.py"
      provides: "Async database session factory"
      contains: "async_session_factory"
    - path: "backend/alembic.ini"
      provides: "Alembic configuration"
      contains: "sqlalchemy.url"
    - path: "backend/migrations/env.py"
      provides: "Alembic migration environment with async support"
      contains: "run_async_migrations"
    - path: "backend/src/atlas/config.py"
      provides: "Application settings via pydantic-settings"
      contains: "class Settings"
  key_links:
    - from: "backend/migrations/env.py"
      to: "backend/src/atlas/adapters/postgresql/models.py"
      via: "model imports before target_metadata"
      pattern: "from atlas.adapters.postgresql.models import"
    - from: "backend/src/atlas/adapters/postgresql/session.py"
      to: "backend/src/atlas/config.py"
      via: "database URL from settings"
      pattern: "settings.database_url"
---

<objective>
Create SQLModel database models and configure Alembic for schema migrations with async PostgreSQL support.

Purpose: Translate domain entities into persistent storage models and establish the migration infrastructure that will manage schema evolution throughout the project lifecycle.

Output: SQLModel table definitions for all entities, async session factory, working Alembic setup that can generate and run migrations against PostgreSQL.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-data-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-data-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-data-architecture/01-01-SUMMARY.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create application settings and SQLModel table models</name>
  <files>
    backend/src/atlas/config.py
    backend/src/atlas/adapters/postgresql/__init__.py
    backend/src/atlas/adapters/postgresql/models.py
  </files>
  <action>
Create configuration and SQLModel table definitions following RESEARCH.md patterns.

1. **Application settings** (`src/atlas/config.py`):
   - Use pydantic-settings for environment configuration
   - Settings class with:
     - `database_url: str` (default: "postgresql+asyncpg://postgres:postgres@localhost:5432/atlas")
     - `database_url_sync: str` (for Alembic: "postgresql+psycopg2://...")
     - `github_token: Optional[str] = None`
     - `github_repo: Optional[str] = None`
     - `debug: bool = False`
   - Load from environment variables with `env_file=".env"`
   - Create singleton `settings = Settings()` for import

2. **SQLModel table models** (`adapters/postgresql/models.py`):

   Per RESEARCH.md Pattern 3 (Many-to-Many) and Catalog Item pattern:

   **UserTeamLink** (link table):
   - `user_id: UUID` (FK to users, primary_key=True)
   - `team_id: UUID` (FK to teams, primary_key=True)
   - `role: str = "member"` (extra field on link)
   - `joined_at: datetime`

   **UserModel** (table="users"):
   - `id: UUID` (primary_key, default uuid4)
   - `email: str` (unique, index)
   - `username: str` (unique, index)
   - `password_hash: str` (for future auth)
   - `created_at: datetime`
   - `updated_at: datetime`
   - `teams: list["TeamModel"]` via Relationship with link_model

   **TeamModel** (table="teams"):
   - `id: UUID` (primary_key)
   - `name: str` (unique, index)
   - `created_at: datetime`
   - `updated_at: datetime`
   - `members: list[UserModel]` via Relationship with link_model

   **CatalogItemModel** (table="catalog_items"):
   - Per RESEARCH.md single-table pattern with type discriminator
   - `id: UUID` (primary_key)
   - `type: CatalogItemType` (enum, index) - import from domain entities
   - `name: str` (index)
   - `description: str`
   - `git_path: str` (unique) - e.g., "skills/my-skill.md"
   - `author_id: UUID` (FK to users)
   - `team_id: Optional[UUID]` (FK to teams, nullable)
   - `tags: str` (JSON string for array - simple approach)
   - `usage_count: int = 0`
   - `created_at: datetime`
   - `updated_at: datetime`

Use `from sqlmodel import SQLModel, Field, Relationship` for all models.
Add proper `__tablename__` to each model.
  </action>
  <verify>
Run `cd backend && python -c "from atlas.adapters.postgresql.models import UserModel, TeamModel, CatalogItemModel, UserTeamLink; from atlas.config import settings; print(f'Models OK, DB URL: {settings.database_url[:30]}...')"`.
  </verify>
  <done>
All SQLModel table definitions created with proper relationships, settings class loads configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create async database session factory</name>
  <files>
    backend/src/atlas/adapters/postgresql/session.py
  </files>
  <action>
Create the async session factory per RESEARCH.md Pattern 1.

1. Create `adapters/postgresql/session.py`:
   ```python
   from sqlmodel import SQLModel
   from sqlmodel.ext.asyncio.session import AsyncSession
   from sqlalchemy.ext.asyncio import create_async_engine, AsyncEngine
   from sqlalchemy.orm import sessionmaker
   from typing import AsyncGenerator

   from atlas.config import settings
   ```

2. Create async engine with:
   - `echo=False` (set True for SQL logging in dev via settings.debug)
   - `future=True`
   - `pool_size=5`
   - `max_overflow=10`

3. Create `async_session_factory` using sessionmaker:
   - `class_=AsyncSession`
   - `expire_on_commit=False` (CRITICAL per RESEARCH.md Pitfall 3)

4. Create dependency function `async def get_session() -> AsyncGenerator[AsyncSession, None]`:
   - Uses context manager pattern
   - Yields session for FastAPI dependency injection

5. Create helper `async def init_db()` for creating tables (dev/test use):
   - Uses `async with engine.begin()`
   - Calls `await conn.run_sync(SQLModel.metadata.create_all)`
  </action>
  <verify>
Run `cd backend && python -c "from atlas.adapters.postgresql.session import engine, async_session_factory, get_session; print('Session factory OK')"`.
  </verify>
  <done>
Async session factory configured with proper pooling and expire_on_commit=False.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure Alembic for async migrations</name>
  <files>
    backend/alembic.ini
    backend/migrations/env.py
    backend/migrations/script.py.mako
  </files>
  <action>
Initialize and configure Alembic for async SQLModel migrations.

1. Initialize Alembic with async template:
   ```bash
   cd backend && alembic init -t async migrations
   ```

2. Update `alembic.ini`:
   - Set `sqlalchemy.url` placeholder (will be overridden in env.py)
   - Keep file_template for readable migration names

3. Update `migrations/env.py` per RESEARCH.md code example:

   CRITICAL ORDERING:
   ```python
   # Step 1: Import models FIRST (before SQLModel.metadata)
   from atlas.adapters.postgresql.models import *

   # Step 2: Then import SQLModel for metadata
   from sqlmodel import SQLModel

   # Step 3: Get settings for database URL
   from atlas.config import settings
   ```

   Add naming convention for constraints (from RESEARCH.md):
   ```python
   NAMING_CONVENTION = {
       "ix": "ix_%(column_0_label)s",
       "uq": "uq_%(table_name)s_%(column_0_name)s",
       "ck": "ck_%(table_name)s_%(constraint_name)s",
       "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
       "pk": "pk_%(table_name)s",
   }
   target_metadata.naming_convention = NAMING_CONVENTION
   ```

   Configure context with:
   - `render_as_batch=True`
   - `user_module_prefix="sqlmodel.sql.sqltypes."` (per RESEARCH.md Pitfall 2)

   Override URL from settings in `run_migrations_online`:
   - Use `settings.database_url_sync` (psycopg2 URL for migrations)

4. Keep default `script.py.mako` template.

5. Create initial migration:
   ```bash
   cd backend && alembic revision --autogenerate -m "initial schema"
   ```

   Verify the generated migration contains:
   - users table
   - teams table
   - catalog_items table
   - user_team_links table
  </action>
  <verify>
Run the following commands:
1. `cd backend && alembic check` - should show no issues
2. `cd backend && alembic revision --autogenerate -m "test" --sql` - should show CREATE TABLE statements (can discard after)
3. Verify migrations/versions/ contains at least one .py file
  </verify>
  <done>
Alembic configured for async PostgreSQL, initial migration generated with all tables, naming conventions applied.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Import chain verification:
   ```bash
   cd backend && python -c "
   from atlas.config import settings
   from atlas.adapters.postgresql.models import UserModel, TeamModel, CatalogItemModel
   from atlas.adapters.postgresql.session import engine, async_session_factory
   print(f'Database URL: {settings.database_url[:40]}...')
   print(f'Engine: {engine}')
   print('All imports successful')
   "
   ```

2. Alembic configuration check:
   ```bash
   cd backend && alembic check
   ```

3. Migration files exist:
   ```bash
   ls backend/migrations/versions/*.py | head -1
   ```

4. Model relationships check:
   ```bash
   cd backend && python -c "
   from atlas.adapters.postgresql.models import UserModel
   print(f'UserModel relationships: {UserModel.__sqlmodel_relationships__}')
   "
   ```
</verification>

<success_criteria>
- Application settings load from environment via pydantic-settings
- SQLModel table models exist for User, Team, CatalogItem with proper relationships
- UserTeamLink implements many-to-many between users and teams
- CatalogItem uses single-table pattern with type discriminator
- Async session factory configured with expire_on_commit=False
- Alembic initialized with async template
- env.py imports models before metadata (prevents autogenerate issues)
- Naming convention applied for consistent constraint names
- Initial migration generated (even if not yet run against DB)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-architecture/01-02-SUMMARY.md`
</output>
