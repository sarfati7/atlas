---
phase: 01-foundation-data-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/pyproject.toml
  - backend/src/atlas/__init__.py
  - backend/src/atlas/domain/__init__.py
  - backend/src/atlas/domain/entities/__init__.py
  - backend/src/atlas/domain/entities/user.py
  - backend/src/atlas/domain/entities/team.py
  - backend/src/atlas/domain/entities/catalog_item.py
  - backend/src/atlas/domain/value_objects/__init__.py
  - backend/src/atlas/domain/value_objects/email.py
  - backend/src/atlas/domain/errors/__init__.py
  - backend/src/atlas/domain/errors/domain_errors.py
  - backend/src/atlas/domain/interfaces/__init__.py
  - backend/src/atlas/domain/interfaces/user_repository.py
  - backend/src/atlas/domain/interfaces/team_repository.py
  - backend/src/atlas/domain/interfaces/catalog_repository.py
  - backend/src/atlas/domain/interfaces/content_repository.py
  - backend/src/atlas/domain/interfaces/authorization.py
autonomous: true

must_haves:
  truths:
    - "Project structure follows DDD/Clean Architecture with domain/application/adapters/entrypoints layers"
    - "Domain entities exist for User, Team, and CatalogItem with proper typing"
    - "Repository interfaces define contracts for all data access operations"
    - "Domain layer has zero external dependencies (no I/O, no frameworks)"
  artifacts:
    - path: "backend/pyproject.toml"
      provides: "Python project configuration with uv"
      contains: "fastapi"
    - path: "backend/src/atlas/domain/entities/user.py"
      provides: "User entity definition"
      contains: "class User"
    - path: "backend/src/atlas/domain/entities/team.py"
      provides: "Team entity definition"
      contains: "class Team"
    - path: "backend/src/atlas/domain/entities/catalog_item.py"
      provides: "CatalogItem entity with type discriminator"
      contains: "CatalogItemType"
    - path: "backend/src/atlas/domain/interfaces/user_repository.py"
      provides: "User repository abstract interface"
      contains: "AbstractUserRepository"
    - path: "backend/src/atlas/domain/interfaces/content_repository.py"
      provides: "Git content repository abstract interface"
      contains: "AbstractContentRepository"
  key_links:
    - from: "backend/src/atlas/domain/interfaces/"
      to: "backend/src/atlas/domain/entities/"
      via: "type imports for return types"
      pattern: "from.*entities.*import"
---

<objective>
Establish project structure and domain layer following DDD/Clean Architecture principles.

Purpose: Create the foundational folder structure and pure business domain that all other layers will depend on. The domain layer defines the "truth" of the system with entities, value objects, and repository interfaces - with zero I/O dependencies.

Output: A Python project with uv configuration, and a complete domain layer including User, Team, CatalogItem entities, value objects, domain errors, and abstract repository interfaces.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-data-architecture/01-RESEARCH.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project structure and Python configuration</name>
  <files>
    backend/pyproject.toml
    backend/src/atlas/__init__.py
    backend/src/atlas/domain/__init__.py
    backend/src/atlas/application/__init__.py
    backend/src/atlas/adapters/__init__.py
    backend/src/atlas/entrypoints/__init__.py
  </files>
  <action>
Create the backend folder structure following the DDD/Clean Architecture pattern from RESEARCH.md:

1. Create `backend/pyproject.toml` with:
   - name: "atlas"
   - Python 3.12+ requirement
   - Dependencies: fastapi, sqlmodel, asyncpg, psycopg2-binary, alembic, pygithub, pydantic-settings, greenlet, uvicorn
   - Dev dependencies: pytest, pytest-asyncio, httpx
   - Use modern pyproject.toml format (no setup.py)

2. Create folder structure:
   ```
   backend/
   ├── src/
   │   └── atlas/
   │       ├── __init__.py
   │       ├── domain/
   │       │   └── __init__.py
   │       ├── application/
   │       │   └── __init__.py
   │       ├── adapters/
   │       │   └── __init__.py
   │       └── entrypoints/
   │           └── __init__.py
   └── pyproject.toml
   ```

3. Each `__init__.py` should be empty or minimal (just package marker).

Use uv for package management as recommended in RESEARCH.md. The pyproject.toml should be compatible with uv.
  </action>
  <verify>
Run `cd backend && uv sync` successfully. Verify folder structure exists with `ls -R backend/src/atlas/`.
  </verify>
  <done>
Backend project initialized with uv, all layer folders created, dependencies installable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create domain entities and value objects</name>
  <files>
    backend/src/atlas/domain/entities/__init__.py
    backend/src/atlas/domain/entities/user.py
    backend/src/atlas/domain/entities/team.py
    backend/src/atlas/domain/entities/catalog_item.py
    backend/src/atlas/domain/value_objects/__init__.py
    backend/src/atlas/domain/value_objects/email.py
    backend/src/atlas/domain/errors/__init__.py
    backend/src/atlas/domain/errors/domain_errors.py
  </files>
  <action>
Create pure domain entities following RESEARCH.md patterns. These are dataclasses/Pydantic models with NO I/O dependencies.

1. **User entity** (`domain/entities/user.py`):
   - Fields: id (UUID), email (str), username (str), created_at, updated_at
   - Use Pydantic BaseModel for validation (not SQLModel - that's for adapters)
   - User can belong to multiple teams (store team_ids as list)

2. **Team entity** (`domain/entities/team.py`):
   - Fields: id (UUID), name (str), created_at, updated_at
   - Teams have member_ids (list of UUIDs)

3. **CatalogItem entity** (`domain/entities/catalog_item.py`):
   - Use single entity with CatalogItemType enum (SKILL, MCP, TOOL) per RESEARCH.md recommendation
   - Fields: id, type, name, description, git_path, author_id, team_id (optional), tags (list[str]), usage_count, created_at, updated_at

4. **Email value object** (`domain/value_objects/email.py`):
   - Wraps string with validation (basic format check)
   - Immutable (frozen dataclass or Pydantic model with frozen=True)

5. **Domain errors** (`domain/errors/domain_errors.py`):
   - Base `DomainError` exception
   - `EntityNotFoundError(entity_type, entity_id)`
   - `ValidationError(message)`
   - `AuthorizationError(message)`

6. Update `__init__.py` files to export main classes.

CRITICAL: Domain layer must NOT import from adapters, application, or entrypoints. Only stdlib and pydantic allowed.
  </action>
  <verify>
Run `cd backend && python -c "from atlas.domain.entities import User, Team, CatalogItem; from atlas.domain.value_objects import Email; from atlas.domain.errors import DomainError; print('Domain imports OK')"`.
  </verify>
  <done>
All domain entities importable, no I/O dependencies, proper typing throughout.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create repository and service interfaces</name>
  <files>
    backend/src/atlas/domain/interfaces/__init__.py
    backend/src/atlas/domain/interfaces/user_repository.py
    backend/src/atlas/domain/interfaces/team_repository.py
    backend/src/atlas/domain/interfaces/catalog_repository.py
    backend/src/atlas/domain/interfaces/content_repository.py
    backend/src/atlas/domain/interfaces/authorization.py
  </files>
  <action>
Create abstract repository interfaces per RESEARCH.md Pattern 2 and Pattern 4.

1. **AbstractUserRepository** (`interfaces/user_repository.py`):
   - `async def get_by_id(user_id: UUID) -> Optional[User]`
   - `async def get_by_email(email: str) -> Optional[User]`
   - `async def save(user: User) -> User`
   - `async def delete(user_id: UUID) -> bool`
   - `async def list_all() -> list[User]`

2. **AbstractTeamRepository** (`interfaces/team_repository.py`):
   - `async def get_by_id(team_id: UUID) -> Optional[Team]`
   - `async def get_by_name(name: str) -> Optional[Team]`
   - `async def save(team: Team) -> Team`
   - `async def delete(team_id: UUID) -> bool`
   - `async def list_all() -> list[Team]`
   - `async def get_user_teams(user_id: UUID) -> list[Team]`

3. **AbstractCatalogRepository** (`interfaces/catalog_repository.py`):
   - `async def get_by_id(item_id: UUID) -> Optional[CatalogItem]`
   - `async def get_by_git_path(git_path: str) -> Optional[CatalogItem]`
   - `async def save(item: CatalogItem) -> CatalogItem`
   - `async def delete(item_id: UUID) -> bool`
   - `async def list_by_type(item_type: CatalogItemType) -> list[CatalogItem]`
   - `async def search(query: str) -> list[CatalogItem]`

4. **AbstractContentRepository** (`interfaces/content_repository.py`):
   - Git content operations (per RESEARCH.md Pattern 5)
   - `async def get_content(path: str) -> Optional[str]`
   - `async def save_content(path: str, content: str, message: str) -> str`  # Returns commit SHA
   - `async def delete_content(path: str, message: str) -> str`
   - `async def list_contents(directory: str) -> list[str]`  # List file paths

5. **AbstractAuthorizationService** (`interfaces/authorization.py`):
   - Per RESEARCH.md Pattern 4
   - `async def can_view_skill(user: User, skill: CatalogItem) -> bool`
   - `async def can_edit_skill(user: User, skill: CatalogItem) -> bool`
   - `async def can_delete_skill(user: User, skill: CatalogItem) -> bool`
   - Same for MCP and Tool variants

All interfaces use `ABC` and `@abstractmethod`. Import domain entities for type hints.
  </action>
  <verify>
Run `cd backend && python -c "from atlas.domain.interfaces import AbstractUserRepository, AbstractTeamRepository, AbstractCatalogRepository, AbstractContentRepository, AbstractAuthorizationService; print('Interfaces OK')"`.
  </verify>
  <done>
All repository interfaces defined as abstract classes, proper async signatures, correct return types using domain entities.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Folder structure check:
   ```bash
   ls -la backend/src/atlas/domain/
   # Should show: entities/, value_objects/, errors/, interfaces/
   ```

2. Dependency check - domain has no I/O imports:
   ```bash
   cd backend && grep -r "import sqlmodel\|import asyncpg\|import github" src/atlas/domain/ || echo "No I/O imports in domain - GOOD"
   ```

3. Full import test:
   ```bash
   cd backend && python -c "
   from atlas.domain.entities import User, Team, CatalogItem, CatalogItemType
   from atlas.domain.value_objects import Email
   from atlas.domain.errors import DomainError, EntityNotFoundError
   from atlas.domain.interfaces import (
       AbstractUserRepository,
       AbstractTeamRepository,
       AbstractCatalogRepository,
       AbstractContentRepository,
       AbstractAuthorizationService
   )
   print('All domain imports successful')
   "
   ```
</verification>

<success_criteria>
- Backend project structure created with DDD layers (domain/application/adapters/entrypoints)
- pyproject.toml with all required dependencies, uv sync successful
- Domain entities (User, Team, CatalogItem) exist with proper typing
- Value objects (Email) exist with validation
- Domain errors hierarchy established
- All repository interfaces defined as abstract classes
- Authorization interface defined (for future RBAC implementation)
- Domain layer has zero I/O dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-architecture/01-01-SUMMARY.md`
</output>
