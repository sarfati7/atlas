---
phase: 03-catalog-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/atlas/domain/interfaces/catalog_repository.py
  - backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py
  - backend/src/atlas/adapters/in_memory/repositories/catalog_repository.py
  - backend/src/atlas/entrypoints/api/routes/catalog.py
  - backend/src/atlas/entrypoints/api/routes/__init__.py
  - backend/src/atlas/entrypoints/app.py
autonomous: true

must_haves:
  truths:
    - "API returns paginated list of catalog items at GET /api/v1/catalog"
    - "API supports type filter via query parameter (?type=skill)"
    - "API supports keyword search via query parameter (?q=docker)"
    - "Pagination metadata includes total, page, size, pages"
  artifacts:
    - path: "backend/src/atlas/domain/interfaces/catalog_repository.py"
      provides: "PaginatedResult dataclass and list_paginated method in interface"
      contains: "list_paginated"
    - path: "backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py"
      provides: "PostgreSQL implementation of list_paginated"
      contains: "async def list_paginated"
    - path: "backend/src/atlas/entrypoints/api/routes/catalog.py"
      provides: "Catalog list endpoint with pagination, search, filter"
      exports: ["router"]
  key_links:
    - from: "backend/src/atlas/entrypoints/api/routes/catalog.py"
      to: "backend/src/atlas/domain/interfaces/catalog_repository.py"
      via: "CatalogRepo dependency"
      pattern: "catalog_repo.*list_paginated"
    - from: "backend/src/atlas/entrypoints/app.py"
      to: "backend/src/atlas/entrypoints/api/routes/catalog.py"
      via: "Router import and include_router"
      pattern: "catalog_router"
---

<objective>
Implement the catalog list endpoint with pagination, search, and type filtering

Purpose: Enable browsing of all skills, MCPs, and tools with search/filter capabilities (CATL-01 through CATL-05)
Output: Working GET /api/v1/catalog endpoint returning paginated, searchable, filterable catalog items
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-catalog-backend/03-RESEARCH.md

# Existing files to modify
@backend/src/atlas/domain/interfaces/catalog_repository.py
@backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py
@backend/src/atlas/adapters/in_memory/repositories/catalog_repository.py
@backend/src/atlas/entrypoints/api/routes/__init__.py
@backend/src/atlas/entrypoints/app.py
@backend/src/atlas/entrypoints/dependencies.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add list_paginated method to repository interface and implementations</name>
  <files>
    backend/src/atlas/domain/interfaces/catalog_repository.py
    backend/src/atlas/adapters/postgresql/repositories/catalog_repository.py
    backend/src/atlas/adapters/in_memory/repositories/catalog_repository.py
  </files>
  <action>
Add paginated listing capability to the catalog repository:

1. In `catalog_repository.py` interface:
   - Add dataclass `PaginatedResult` at top of file:
     ```python
     from dataclasses import dataclass

     @dataclass
     class PaginatedResult:
         """Container for paginated query results."""
         items: list[CatalogItem]
         total: int
     ```
   - Add abstract method `list_paginated` to `AbstractCatalogRepository`:
     ```python
     @abstractmethod
     async def list_paginated(
         self,
         offset: int,
         limit: int,
         item_type: Optional[CatalogItemType] = None,
         search_query: Optional[str] = None,
     ) -> PaginatedResult:
         """
         Retrieve paginated catalog items with optional filtering.

         Args:
             offset: Number of items to skip
             limit: Maximum items to return
             item_type: Filter by item type (SKILL, MCP, TOOL)
             search_query: Search in name, description, tags (case-insensitive)

         Returns:
             PaginatedResult with items and total count
         """
         raise NotImplementedError
     ```
   - Export `PaginatedResult` in module's `__all__` if exists

2. In PostgreSQL `catalog_repository.py`:
   - Import `func` from sqlalchemy and `PaginatedResult` from interface
   - Implement `list_paginated`:
     - Build base SELECT and COUNT statements
     - Apply type filter with WHERE clause if item_type provided
     - Apply search filter with OR(name ILIKE, description ILIKE, tags ILIKE) if search_query provided
     - Execute count query first to get total
     - Apply ORDER BY name, OFFSET, LIMIT to select query
     - Return PaginatedResult(items=converted_entities, total=count)

3. In in-memory `catalog_repository.py`:
   - Import `PaginatedResult` from interface
   - Implement `list_paginated`:
     - Start with all items from self._items.values()
     - Filter by type if provided
     - Filter by search (check name, description, tags case-insensitive) if provided
     - Sort by name
     - Get total count before slicing
     - Apply offset and limit via list slicing
     - Return PaginatedResult
  </action>
  <verify>
    Run: `cd /Users/roysarfati/PycharmProjects/atlas/backend && uv run python -c "from atlas.domain.interfaces.catalog_repository import AbstractCatalogRepository, PaginatedResult; print('Interface OK')"` should print "Interface OK"
  </verify>
  <done>
    - PaginatedResult dataclass exists in interface module
    - list_paginated method in interface with offset, limit, item_type, search_query params
    - PostgreSQL implementation uses ILIKE for search, func.count for total
    - In-memory implementation filters and slices correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create catalog list endpoint with response models</name>
  <files>
    backend/src/atlas/entrypoints/api/routes/catalog.py
    backend/src/atlas/entrypoints/api/routes/__init__.py
    backend/src/atlas/entrypoints/app.py
  </files>
  <action>
Create the catalog routes module and wire it into the application:

1. Create `backend/src/atlas/entrypoints/api/routes/catalog.py`:
   ```python
   """Catalog routes - Browse skills, MCPs, and tools."""

   import math
   from typing import Optional
   from uuid import UUID

   from fastapi import APIRouter, Query
   from pydantic import BaseModel

   from atlas.domain.entities.catalog_item import CatalogItemType
   from atlas.entrypoints.dependencies import CatalogRepo

   router = APIRouter(prefix="/catalog", tags=["catalog"])


   class CatalogItemSummary(BaseModel):
       """Summary view for catalog list (excludes documentation)."""
       id: UUID
       type: CatalogItemType
       name: str
       description: str
       tags: list[str]
       author_id: UUID
       team_id: Optional[UUID]
       usage_count: int


   class PaginatedCatalog(BaseModel):
       """Paginated catalog response."""
       items: list[CatalogItemSummary]
       total: int
       page: int
       size: int
       pages: int


   @router.get("", response_model=PaginatedCatalog)
   async def list_catalog(
       catalog_repo: CatalogRepo,
       page: int = Query(default=1, ge=1, description="Page number (1-indexed)"),
       size: int = Query(default=20, ge=1, le=100, description="Items per page (max 100)"),
       type: Optional[CatalogItemType] = Query(default=None, description="Filter by type"),
       q: Optional[str] = Query(default=None, min_length=1, description="Search keyword"),
   ) -> PaginatedCatalog:
       """
       List catalog items with pagination, filtering, and search.

       - **page**: Page number starting from 1
       - **size**: Number of items per page (1-100)
       - **type**: Filter by item type (skill, mcp, tool)
       - **q**: Search in name, description, and tags (case-insensitive)

       Returns all skills, MCPs, and tools available company-wide.
       """
       offset = (page - 1) * size

       result = await catalog_repo.list_paginated(
           offset=offset,
           limit=size,
           item_type=type,
           search_query=q,
       )

       pages = math.ceil(result.total / size) if result.total > 0 else 1

       items = [
           CatalogItemSummary(
               id=item.id,
               type=item.type,
               name=item.name,
               description=item.description,
               tags=item.tags,
               author_id=item.author_id,
               team_id=item.team_id,
               usage_count=item.usage_count,
           )
           for item in result.items
       ]

       return PaginatedCatalog(
           items=items,
           total=result.total,
           page=page,
           size=size,
           pages=pages,
       )
   ```

2. Update `backend/src/atlas/entrypoints/api/routes/__init__.py`:
   - Add import: `from atlas.entrypoints.api.routes.catalog import router as catalog_router`
   - Add to `__all__`: `"catalog_router"`

3. Update `backend/src/atlas/entrypoints/app.py`:
   - Add `catalog_router` to import from routes
   - Add `app.include_router(catalog_router, prefix="/api/v1")` after other routers
  </action>
  <verify>
    Run: `cd /Users/roysarfati/PycharmProjects/atlas/backend && uv run python -c "from atlas.entrypoints.app import app; routes = [r.path for r in app.routes]; assert '/api/v1/catalog' in routes or any('/catalog' in str(r.path) for r in app.routes), f'Routes: {routes}'; print('Router wired OK')"` should print "Router wired OK"
  </verify>
  <done>
    - catalog.py route file exists with list_catalog endpoint
    - CatalogItemSummary and PaginatedCatalog response models defined
    - Endpoint accepts page, size, type, q query parameters
    - Router exported from routes/__init__.py
    - Router included in app.py with /api/v1 prefix
    - GET /api/v1/catalog endpoint available
  </done>
</task>

<task type="auto">
  <name>Task 3: Manual API verification</name>
  <files>None (verification only)</files>
  <action>
Test the catalog endpoint manually to verify all requirements:

1. Start the development server (if not running):
   `cd /Users/roysarfati/PycharmProjects/atlas/backend && uv run uvicorn atlas.entrypoints.app:app --reload --port 8000`

2. Test basic list endpoint:
   `curl -s http://localhost:8000/api/v1/catalog | python -m json.tool`
   Expected: JSON response with items, total, page, size, pages fields

3. Test pagination:
   `curl -s "http://localhost:8000/api/v1/catalog?page=1&size=5" | python -m json.tool`
   Expected: size=5 in response, items array with max 5 items

4. Test type filter:
   `curl -s "http://localhost:8000/api/v1/catalog?type=skill" | python -m json.tool`
   Expected: All items in response have type="skill" (or empty if no skills)

5. Test search:
   `curl -s "http://localhost:8000/api/v1/catalog?q=test" | python -m json.tool`
   Expected: 200 response (items may be empty if no matches)

6. Test combined filters:
   `curl -s "http://localhost:8000/api/v1/catalog?type=mcp&q=docker&page=1&size=10" | python -m json.tool`
   Expected: 200 response with correct pagination metadata

7. Check OpenAPI docs:
   Open http://localhost:8000/docs in browser
   Expected: /api/v1/catalog endpoint documented with query parameters

Note: If database is empty, responses will have total=0 and empty items array, which is correct behavior.
  </action>
  <verify>
    All curl commands return 200 status with valid JSON structure matching PaginatedCatalog schema
  </verify>
  <done>
    - GET /api/v1/catalog returns paginated response
    - ?type= filter works (returns only items of specified type)
    - ?q= search works (returns matching items)
    - ?page= and ?size= pagination works
    - Combined filters work together
    - OpenAPI documentation shows all parameters
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `curl http://localhost:8000/api/v1/catalog` returns valid JSON with pagination envelope
2. `curl "http://localhost:8000/api/v1/catalog?type=skill"` filters by type
3. `curl "http://localhost:8000/api/v1/catalog?q=test"` performs search
4. `curl "http://localhost:8000/api/v1/catalog?page=2&size=10"` paginates correctly
5. OpenAPI docs at /docs show the endpoint with all query parameters
</verification>

<success_criteria>
- GET /api/v1/catalog endpoint exists and returns 200
- Response includes: items, total, page, size, pages
- Type filter restricts results to specified CatalogItemType
- Search query matches against name, description, tags (case-insensitive)
- Pagination calculates pages correctly (ceil(total/size))
- Max page size enforced at 100
- Requirements CATL-01, CATL-02, CATL-03, CATL-04, CATL-05 addressed by this endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/03-catalog-backend/03-01-SUMMARY.md`
</output>
