---
phase: 06-web-frontend-core
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - frontend/src/stores/authStore.ts
  - frontend/src/features/auth/api/authApi.ts
  - frontend/src/features/auth/hooks/useAuth.ts
  - frontend/src/features/auth/components/LoginForm.tsx
  - frontend/src/features/auth/components/SignupForm.tsx
  - frontend/src/features/auth/components/ForgotPasswordForm.tsx
  - frontend/src/features/auth/types.ts
  - frontend/src/routes/login.tsx
  - frontend/src/routes/signup.tsx
  - frontend/src/routes/reset-password.tsx
  - frontend/src/routes/router.tsx
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "User can submit signup form and see success message"
    - "User can submit login form and get redirected"
    - "User can click forgot password link and enter email"
    - "Invalid credentials show inline error message"
    - "Auth state persists on page refresh"
  artifacts:
    - path: "frontend/src/stores/authStore.ts"
      provides: "Zustand auth state"
      contains: "isAuthenticated"
    - path: "frontend/src/features/auth/api/authApi.ts"
      provides: "Auth API calls"
      exports: ["authApi"]
    - path: "frontend/src/features/auth/hooks/useAuth.ts"
      provides: "Auth hooks"
      exports: ["useLogin", "useLogout", "useCurrentUser"]
    - path: "frontend/src/routes/login.tsx"
      provides: "Login page component"
      contains: "LoginForm"
    - path: "frontend/src/routes/signup.tsx"
      provides: "Signup page component"
      contains: "SignupForm"
  key_links:
    - from: "frontend/src/features/auth/hooks/useAuth.ts"
      to: "frontend/src/features/auth/api/authApi.ts"
      via: "useMutation calling authApi"
      pattern: "authApi\\."
    - from: "frontend/src/stores/authStore.ts"
      to: "frontend/src/features/auth/hooks/useAuth.ts"
      via: "useLogin updates auth store on success"
      pattern: "setAuthenticated"
    - from: "frontend/src/routes/router.tsx"
      to: "frontend/src/routes/login.tsx"
      via: "Router imports and uses LoginPage"
      pattern: "LoginPage"
---

<objective>
Implement authentication UI with login, signup, and forgot password flows.

Purpose: Enable users to create accounts, log in, and recover passwords through dedicated full-page forms with inline validation errors.

Output: Working auth pages that connect to backend APIs, manage auth state in Zustand, and handle token storage via httpOnly cookies. Auth routes are added to the existing router.tsx created in 06-01.
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-web-frontend-core/06-CONTEXT.md
@.planning/phases/06-web-frontend-core/06-RESEARCH.md
@.planning/phases/06-web-frontend-core/06-01-SUMMARY.md
@backend/src/atlas/entrypoints/api/routes/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth store, API layer, and hooks</name>
  <files>
    frontend/src/stores/authStore.ts
    frontend/src/features/auth/api/authApi.ts
    frontend/src/features/auth/hooks/useAuth.ts
    frontend/src/features/auth/types.ts
  </files>
  <action>
Create the auth infrastructure - Zustand store for UI state, API layer for backend calls, TanStack Query hooks:

1. Create src/features/auth/types.ts:
   ```typescript
   export interface User {
     id: string
     email: string
     username: string
     created_at: string
   }

   export interface LoginResponse {
     access_token: string
     token_type: string
     expires_in: number
   }

   export interface RegisterResponse {
     message: string
     user_id: string
   }

   export interface MessageResponse {
     message: string
   }
   ```

2. Create src/stores/authStore.ts:
   ```typescript
   import { create } from 'zustand'
   import { persist } from 'zustand/middleware'

   interface AuthState {
     isAuthenticated: boolean
     accessToken: string | null
     setAuthenticated: (value: boolean) => void
     setAccessToken: (token: string | null) => void
     logout: () => void
   }

   export const useAuthStore = create<AuthState>()(
     persist(
       (set) => ({
         isAuthenticated: false,
         accessToken: null,
         setAuthenticated: (value) => set({ isAuthenticated: value }),
         setAccessToken: (token) => set({ accessToken: token, isAuthenticated: !!token }),
         logout: () => set({ isAuthenticated: false, accessToken: null }),
       }),
       {
         name: 'atlas-auth',
       }
     )
   )

   // Listen for logout events from API interceptor
   if (typeof window !== 'undefined') {
     window.addEventListener('auth:logout', () => {
       useAuthStore.getState().logout()
     })
   }
   ```

3. Create src/features/auth/api/authApi.ts:
   ```typescript
   import { apiClient } from '@/lib/api'
   import type { User, LoginResponse, RegisterResponse, MessageResponse } from '../types'

   export const authApi = {
     register: async (data: { email: string; password: string; username: string }): Promise<RegisterResponse> => {
       const response = await apiClient.post('/api/v1/auth/register', data)
       return response.data
     },

     login: async (email: string, password: string): Promise<LoginResponse> => {
       // Backend expects OAuth2 form data format
       const formData = new URLSearchParams()
       formData.append('username', email) // OAuth2 spec uses 'username' field for email
       formData.append('password', password)

       const response = await apiClient.post('/api/v1/auth/login', formData, {
         headers: {
           'Content-Type': 'application/x-www-form-urlencoded',
         },
       })
       return response.data
     },

     logout: async (): Promise<MessageResponse> => {
       const response = await apiClient.post('/api/v1/auth/logout')
       return response.data
     },

     getCurrentUser: async (): Promise<User> => {
       const response = await apiClient.get('/api/v1/auth/me')
       return response.data
     },

     forgotPassword: async (email: string): Promise<MessageResponse> => {
       const response = await apiClient.post('/api/v1/auth/forgot-password', { email })
       return response.data
     },

     resetPassword: async (token: string, newPassword: string): Promise<MessageResponse> => {
       const response = await apiClient.post('/api/v1/auth/reset-password', {
         token,
         new_password: newPassword,
       })
       return response.data
     },
   }
   ```

4. Create src/features/auth/hooks/useAuth.ts:
   ```typescript
   import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
   import { useNavigate } from 'react-router-dom'
   import { authApi } from '../api/authApi'
   import { useAuthStore } from '@/stores/authStore'

   export const useCurrentUser = () => {
     const { isAuthenticated } = useAuthStore()

     return useQuery({
       queryKey: ['auth', 'me'],
       queryFn: authApi.getCurrentUser,
       enabled: isAuthenticated,
       retry: false,
     })
   }

   export const useLogin = () => {
     const queryClient = useQueryClient()
     const navigate = useNavigate()
     const { setAccessToken } = useAuthStore()

     return useMutation({
       mutationFn: ({ email, password }: { email: string; password: string }) =>
         authApi.login(email, password),
       onSuccess: (data) => {
         setAccessToken(data.access_token)
         queryClient.invalidateQueries({ queryKey: ['auth', 'me'] })
         navigate('/dashboard')
       },
     })
   }

   export const useRegister = () => {
     return useMutation({
       mutationFn: (data: { email: string; password: string; username: string }) =>
         authApi.register(data),
     })
   }

   export const useLogout = () => {
     const queryClient = useQueryClient()
     const navigate = useNavigate()
     const { logout } = useAuthStore()

     return useMutation({
       mutationFn: authApi.logout,
       onSuccess: () => {
         logout()
         queryClient.clear()
         navigate('/login')
       },
       onError: () => {
         // Even if API fails, clear local state
         logout()
         queryClient.clear()
         navigate('/login')
       },
     })
   }

   export const useForgotPassword = () => {
     return useMutation({
       mutationFn: (email: string) => authApi.forgotPassword(email),
     })
   }

   export const useResetPassword = () => {
     const navigate = useNavigate()

     return useMutation({
       mutationFn: ({ token, newPassword }: { token: string; newPassword: string }) =>
         authApi.resetPassword(token, newPassword),
       onSuccess: () => {
         navigate('/login')
       },
     })
   }
   ```

5. Update API client to use stored access token. Update src/lib/api.ts request interceptor:
   ```typescript
   // Add at the top after imports
   import { useAuthStore } from '@/stores/authStore'

   // Add request interceptor before response interceptor
   apiClient.interceptors.request.use(
     (config) => {
       const token = useAuthStore.getState().accessToken
       if (token) {
         config.headers.Authorization = `Bearer ${token}`
       }
       return config
     },
     (error) => Promise.reject(error)
   )
   ```
  </action>
  <verify>
    cd frontend && npm run build
    # Check for TypeScript errors
    grep -r "useLogin" src/features/auth/hooks/useAuth.ts && echo "Hooks OK"
    grep -r "isAuthenticated" src/stores/authStore.ts && echo "Store OK"
  </verify>
  <done>Auth store, API layer, and TanStack Query hooks created</done>
</task>

<task type="auto">
  <name>Task 2: Create auth form components with validation</name>
  <files>
    frontend/src/features/auth/components/LoginForm.tsx
    frontend/src/features/auth/components/SignupForm.tsx
    frontend/src/features/auth/components/ForgotPasswordForm.tsx
  </files>
  <action>
Create form components using React Hook Form with Zod validation and shadcn/ui:

1. First install required shadcn components:
   ```bash
   cd frontend && npx shadcn@latest add button input label card --yes
   ```

2. Create src/features/auth/components/LoginForm.tsx:
   ```typescript
   import { useState } from 'react'
   import { useForm } from 'react-hook-form'
   import { zodResolver } from '@hookform/resolvers/zod'
   import { z } from 'zod'
   import { Link } from 'react-router-dom'
   import { useLogin } from '../hooks/useAuth'
   import { Button } from '@/components/ui/button'
   import { Input } from '@/components/ui/input'
   import { Label } from '@/components/ui/label'
   import { ForgotPasswordForm } from './ForgotPasswordForm'

   const loginSchema = z.object({
     email: z.string().email('Invalid email address'),
     password: z.string().min(1, 'Password is required'),
   })

   type LoginFormData = z.infer<typeof loginSchema>

   export function LoginForm() {
     const [showForgotPassword, setShowForgotPassword] = useState(false)
     const login = useLogin()

     const {
       register,
       handleSubmit,
       formState: { errors },
     } = useForm<LoginFormData>({
       resolver: zodResolver(loginSchema),
     })

     const onSubmit = (data: LoginFormData) => {
       login.mutate(data)
     }

     if (showForgotPassword) {
       return <ForgotPasswordForm onBack={() => setShowForgotPassword(false)} />
     }

     return (
       <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
         <div className="space-y-2">
           <Label htmlFor="email">Email</Label>
           <Input
             id="email"
             type="email"
             placeholder="you@company.com"
             {...register('email')}
           />
           {errors.email && (
             <p className="text-sm text-destructive">{errors.email.message}</p>
           )}
         </div>

         <div className="space-y-2">
           <Label htmlFor="password">Password</Label>
           <Input
             id="password"
             type="password"
             placeholder="********"
             {...register('password')}
           />
           {errors.password && (
             <p className="text-sm text-destructive">{errors.password.message}</p>
           )}
         </div>

         {login.isError && (
           <p className="text-sm text-destructive">
             Incorrect email or password
           </p>
         )}

         <Button type="submit" className="w-full" disabled={login.isPending}>
           {login.isPending ? 'Signing in...' : 'Sign in'}
         </Button>

         <div className="text-center space-y-2">
           <button
             type="button"
             onClick={() => setShowForgotPassword(true)}
             className="text-sm text-muted-foreground hover:text-foreground"
           >
             Forgot password?
           </button>
           <p className="text-sm text-muted-foreground">
             Don't have an account?{' '}
             <Link to="/signup" className="text-foreground hover:underline">
               Sign up
             </Link>
           </p>
         </div>
       </form>
     )
   }
   ```

3. Create src/features/auth/components/SignupForm.tsx:
   ```typescript
   import { useForm } from 'react-hook-form'
   import { zodResolver } from '@hookform/resolvers/zod'
   import { z } from 'zod'
   import { Link, useNavigate } from 'react-router-dom'
   import { useRegister } from '../hooks/useAuth'
   import { Button } from '@/components/ui/button'
   import { Input } from '@/components/ui/input'
   import { Label } from '@/components/ui/label'
   import { AxiosError } from 'axios'

   const signupSchema = z.object({
     email: z.string().email('Invalid email address'),
     username: z.string().min(3, 'Username must be at least 3 characters'),
     password: z.string().min(8, 'Password must be at least 8 characters'),
     confirmPassword: z.string(),
   }).refine((data) => data.password === data.confirmPassword, {
     message: "Passwords don't match",
     path: ['confirmPassword'],
   })

   type SignupFormData = z.infer<typeof signupSchema>

   export function SignupForm() {
     const navigate = useNavigate()
     const registerMutation = useRegister()

     const {
       register,
       handleSubmit,
       formState: { errors },
       setError,
     } = useForm<SignupFormData>({
       resolver: zodResolver(signupSchema),
     })

     const onSubmit = (data: SignupFormData) => {
       registerMutation.mutate(
         { email: data.email, password: data.password, username: data.username },
         {
           onSuccess: () => {
             navigate('/login')
           },
           onError: (error) => {
             if (error instanceof AxiosError) {
               const detail = error.response?.data?.detail
               if (detail?.includes('Email already')) {
                 setError('email', { message: 'Email already registered' })
               } else if (detail?.includes('Username already')) {
                 setError('username', { message: 'Username already taken' })
               }
             }
           },
         }
       )
     }

     return (
       <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
         <div className="space-y-2">
           <Label htmlFor="email">Email</Label>
           <Input
             id="email"
             type="email"
             placeholder="you@company.com"
             {...register('email')}
           />
           {errors.email && (
             <p className="text-sm text-destructive">{errors.email.message}</p>
           )}
         </div>

         <div className="space-y-2">
           <Label htmlFor="username">Username</Label>
           <Input
             id="username"
             type="text"
             placeholder="johndoe"
             {...register('username')}
           />
           {errors.username && (
             <p className="text-sm text-destructive">{errors.username.message}</p>
           )}
         </div>

         <div className="space-y-2">
           <Label htmlFor="password">Password</Label>
           <Input
             id="password"
             type="password"
             placeholder="********"
             {...register('password')}
           />
           {errors.password && (
             <p className="text-sm text-destructive">{errors.password.message}</p>
           )}
         </div>

         <div className="space-y-2">
           <Label htmlFor="confirmPassword">Confirm Password</Label>
           <Input
             id="confirmPassword"
             type="password"
             placeholder="********"
             {...register('confirmPassword')}
           />
           {errors.confirmPassword && (
             <p className="text-sm text-destructive">{errors.confirmPassword.message}</p>
           )}
         </div>

         {registerMutation.isError && !errors.email && !errors.username && (
           <p className="text-sm text-destructive">
             Registration failed. Please try again.
           </p>
         )}

         <Button type="submit" className="w-full" disabled={registerMutation.isPending}>
           {registerMutation.isPending ? 'Creating account...' : 'Create account'}
         </Button>

         <p className="text-center text-sm text-muted-foreground">
           Already have an account?{' '}
           <Link to="/login" className="text-foreground hover:underline">
             Sign in
           </Link>
         </p>
       </form>
     )
   }
   ```

4. Create src/features/auth/components/ForgotPasswordForm.tsx:
   ```typescript
   import { useForm } from 'react-hook-form'
   import { zodResolver } from '@hookform/resolvers/zod'
   import { z } from 'zod'
   import { useForgotPassword } from '../hooks/useAuth'
   import { Button } from '@/components/ui/button'
   import { Input } from '@/components/ui/input'
   import { Label } from '@/components/ui/label'

   const forgotPasswordSchema = z.object({
     email: z.string().email('Invalid email address'),
   })

   type ForgotPasswordFormData = z.infer<typeof forgotPasswordSchema>

   interface ForgotPasswordFormProps {
     onBack: () => void
   }

   export function ForgotPasswordForm({ onBack }: ForgotPasswordFormProps) {
     const forgotPassword = useForgotPassword()

     const {
       register,
       handleSubmit,
       formState: { errors },
     } = useForm<ForgotPasswordFormData>({
       resolver: zodResolver(forgotPasswordSchema),
     })

     const onSubmit = (data: ForgotPasswordFormData) => {
       forgotPassword.mutate(data.email)
     }

     if (forgotPassword.isSuccess) {
       return (
         <div className="space-y-4 text-center">
           <p className="text-foreground">
             If that email is registered, you will receive a reset link.
           </p>
           <Button variant="outline" onClick={onBack}>
             Back to login
           </Button>
         </div>
       )
     }

     return (
       <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
         <div className="space-y-2">
           <Label htmlFor="email">Email</Label>
           <Input
             id="email"
             type="email"
             placeholder="you@company.com"
             {...register('email')}
           />
           {errors.email && (
             <p className="text-sm text-destructive">{errors.email.message}</p>
           )}
         </div>

         <Button type="submit" className="w-full" disabled={forgotPassword.isPending}>
           {forgotPassword.isPending ? 'Sending...' : 'Send reset link'}
         </Button>

         <button
           type="button"
           onClick={onBack}
           className="w-full text-sm text-muted-foreground hover:text-foreground"
         >
           Back to login
         </button>
       </form>
     )
   }
   ```

5. Create index file for exports:
   ```typescript
   // src/features/auth/components/index.ts
   export { LoginForm } from './LoginForm'
   export { SignupForm } from './SignupForm'
   export { ForgotPasswordForm } from './ForgotPasswordForm'
   ```
  </action>
  <verify>
    cd frontend && npm run build
    grep -r "useForm" src/features/auth/components/LoginForm.tsx && echo "RHF OK"
    grep -r "zodResolver" src/features/auth/components/SignupForm.tsx && echo "Zod OK"
  </verify>
  <done>Form components with React Hook Form + Zod validation created</done>
</task>

<task type="auto">
  <name>Task 3: Create auth pages and add routes to existing router.tsx</name>
  <files>
    frontend/src/routes/login.tsx
    frontend/src/routes/signup.tsx
    frontend/src/routes/reset-password.tsx
    frontend/src/routes/router.tsx
  </files>
  <action>
Create full-page auth routes and ADD auth routes to the existing router.tsx file from 06-01:

1. Create src/routes/login.tsx:
   ```typescript
   import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
   import { LoginForm } from '@/features/auth/components'

   export function LoginPage() {
     return (
       <div className="min-h-screen flex items-center justify-center bg-background p-4">
         <Card className="w-full max-w-md">
           <CardHeader className="text-center">
             <CardTitle className="text-2xl">Welcome back</CardTitle>
             <CardDescription>Sign in to your Atlas account</CardDescription>
           </CardHeader>
           <CardContent>
             <LoginForm />
           </CardContent>
         </Card>
       </div>
     )
   }
   ```

2. Create src/routes/signup.tsx:
   ```typescript
   import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
   import { SignupForm } from '@/features/auth/components'

   export function SignupPage() {
     return (
       <div className="min-h-screen flex items-center justify-center bg-background p-4">
         <Card className="w-full max-w-md">
           <CardHeader className="text-center">
             <CardTitle className="text-2xl">Create an account</CardTitle>
             <CardDescription>Get started with Atlas</CardDescription>
           </CardHeader>
           <CardContent>
             <SignupForm />
           </CardContent>
         </Card>
       </div>
     )
   }
   ```

3. Create src/routes/reset-password.tsx:
   ```typescript
   import { useSearchParams, useNavigate } from 'react-router-dom'
   import { useForm } from 'react-hook-form'
   import { zodResolver } from '@hookform/resolvers/zod'
   import { z } from 'zod'
   import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
   import { Button } from '@/components/ui/button'
   import { Input } from '@/components/ui/input'
   import { Label } from '@/components/ui/label'
   import { useResetPassword } from '@/features/auth/hooks/useAuth'

   const resetPasswordSchema = z.object({
     password: z.string().min(8, 'Password must be at least 8 characters'),
     confirmPassword: z.string(),
   }).refine((data) => data.password === data.confirmPassword, {
     message: "Passwords don't match",
     path: ['confirmPassword'],
   })

   type ResetPasswordFormData = z.infer<typeof resetPasswordSchema>

   export function ResetPasswordPage() {
     const [searchParams] = useSearchParams()
     const navigate = useNavigate()
     const token = searchParams.get('token')
     const resetPassword = useResetPassword()

     const {
       register,
       handleSubmit,
       formState: { errors },
     } = useForm<ResetPasswordFormData>({
       resolver: zodResolver(resetPasswordSchema),
     })

     if (!token) {
       return (
         <div className="min-h-screen flex items-center justify-center bg-background p-4">
           <Card className="w-full max-w-md">
             <CardContent className="pt-6 text-center">
               <p className="text-destructive">Invalid reset link</p>
               <Button
                 variant="outline"
                 className="mt-4"
                 onClick={() => navigate('/login')}
               >
                 Back to login
               </Button>
             </CardContent>
           </Card>
         </div>
       )
     }

     const onSubmit = (data: ResetPasswordFormData) => {
       resetPassword.mutate({ token, newPassword: data.password })
     }

     return (
       <div className="min-h-screen flex items-center justify-center bg-background p-4">
         <Card className="w-full max-w-md">
           <CardHeader className="text-center">
             <CardTitle className="text-2xl">Reset password</CardTitle>
             <CardDescription>Enter your new password</CardDescription>
           </CardHeader>
           <CardContent>
             <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
               <div className="space-y-2">
                 <Label htmlFor="password">New Password</Label>
                 <Input
                   id="password"
                   type="password"
                   placeholder="********"
                   {...register('password')}
                 />
                 {errors.password && (
                   <p className="text-sm text-destructive">{errors.password.message}</p>
                 )}
               </div>

               <div className="space-y-2">
                 <Label htmlFor="confirmPassword">Confirm Password</Label>
                 <Input
                   id="confirmPassword"
                   type="password"
                   placeholder="********"
                   {...register('confirmPassword')}
                 />
                 {errors.confirmPassword && (
                   <p className="text-sm text-destructive">{errors.confirmPassword.message}</p>
                 )}
               </div>

               {resetPassword.isError && (
                 <p className="text-sm text-destructive">
                   Invalid or expired reset link
                 </p>
               )}

               <Button type="submit" className="w-full" disabled={resetPassword.isPending}>
                 {resetPassword.isPending ? 'Resetting...' : 'Reset password'}
               </Button>
             </form>
           </CardContent>
         </Card>
       </div>
     )
   }
   ```

4. MODIFY src/routes/router.tsx - Add imports and routes to the existing file:

   Read the existing router.tsx file created in 06-01 first, then ADD the following:

   **Add these imports at the top:**
   ```typescript
   import { LoginPage } from './login'
   import { SignupPage } from './signup'
   import { ResetPasswordPage } from './reset-password'
   ```

   **Add these route objects to the existing createBrowserRouter array:**
   ```typescript
   // Auth routes - no sidebar/layout
   {
     path: '/login',
     element: <LoginPage />,
   },
   {
     path: '/signup',
     element: <SignupPage />,
   },
   {
     path: '/reset-password',
     element: <ResetPasswordPage />,
   },
   ```

   **Also add placeholder routes for pages coming in later plans:**
   ```typescript
   // Placeholder routes for upcoming features
   {
     path: '/catalog',
     element: <div className="min-h-screen flex items-center justify-center bg-background text-foreground">Catalog (coming in 06-03)</div>,
   },
   {
     path: '/dashboard',
     element: <div className="min-h-screen flex items-center justify-center bg-background text-foreground">Dashboard (coming in 06-05)</div>,
   },
   ```

IMPORTANT: Do NOT replace the entire file. ADD imports and route objects to the existing createBrowserRouter array structure. Preserve any existing configuration from 06-01. Do NOT modify App.tsx - it already uses RouterProvider.
  </action>
  <verify>
    cd frontend && npm run build
    # Check routing is configured in router.tsx
    grep -r "LoginPage" src/routes/router.tsx && echo "Router OK"
    grep -r "createBrowserRouter" src/routes/router.tsx && echo "createBrowserRouter OK"
  </verify>
  <done>Auth pages created, routes added to router.tsx</done>
</task>

</tasks>

<verification>
- `cd frontend && npm run build` completes without errors
- Navigate to /login shows login form
- Navigate to /signup shows signup form
- Form validation shows inline errors on invalid input
- Login attempt with wrong credentials shows error message
- Successful login redirects to /dashboard
- Auth state persists in localStorage (atlas-auth key)
- router.tsx uses createBrowserRouter (not BrowserRouter)
</verification>

<success_criteria>
1. Login form validates email and password
2. Signup form validates all fields including password match
3. Forgot password switches form in place
4. Error messages appear below the relevant field
5. Loading states show during API calls
6. Successful login stores token and redirects
7. Auth store persists authentication state
8. Routes added to router.tsx by modifying existing file, App.tsx unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/06-web-frontend-core/06-02-SUMMARY.md`
</output>
